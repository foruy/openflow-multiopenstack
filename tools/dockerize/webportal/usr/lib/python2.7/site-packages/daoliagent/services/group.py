from oslo.config import cfg

from ryu.ofproto import inet
from ryu.ofproto import ether
from ryu.lib import dpid as dpid_lib

from daoliagent.lib import REDIRECT_TABLE
from daoliagent.lib import REDIRECT_PORTS
from daoliagent.services.base import PacketBase
from daoliagent.openstack.common import log as logging

CONF = cfg.CONF

LOG = logging.getLogger(__name__)

class PacketGroup(PacketBase):
    priority = 1

    def init_flow(self, dp, gateway):
        if gateway is None:
            return None

        server_port = self.port_get(dp, devname=gateway['ext_dev'])
        ofp, ofp_parser, ofp_set, ofp_out = self.ofp_get(dp)
        #actions = [ofp_out(ofp.OFPP_NORMAL, 0)]
        #self.add_flow(dp, actions=actions, table_id=REDIRECT_TABLE, idle_timeout=0)

        for port in REDIRECT_PORTS:
            input_match = ofp_parser.OFPMatch(in_port=server_port.port_no,
                                              eth_type=ether.ETH_TYPE_IP,
                                              ip_proto=inet.IPPROTO_TCP,
                                              ipv4_dst=gateway['ext_ip'],
                                              tcp_dst=port)
            input_actions = [ofp_out(ofp.OFPP_LOCAL)]
            output_match = ofp_parser.OFPMatch(in_port=ofp.OFPP_LOCAL,
                                               eth_type=ether.ETH_TYPE_IP,
                                               ip_proto=inet.IPPROTO_TCP,
                                               ipv4_src=gateway['ext_ip'],
                                               tcp_src=port)
            output_actions = [ofp_out(server_port.port_no)]
            self.add_flow(dp, match=input_match, actions=input_actions, idle_timeout=0)
            self.add_flow(dp, match=output_match, actions=output_actions, idle_timeout=0)

        #if gateway['ext_dev'] != gateway['int_dev']:
        #    int_port = self.port_get(dp, devname=gateway['int_dev'])
        #    tap_port = self.port_get(dp, devname=gateway['vint_dev'])

        #    if not int_port or not tap_port:
        #        raise Exception("The device could not be found")

        #    input_match = ofp_parser.OFPMatch(in_port=int_port.port_no,
        #                                      eth_type=ether.ETH_TYPE_IP,
        #                                      ipv4_dst=gateway['int_ip'])
        #    input_actions = [ofp_out(tap_port.port_no)]

        #    output_match = ofp_parser.OFPMatch(in_port=tap_port.port_no,
        #                                       eth_type=ether.ETH_TYPE_IP,
        #                                       ipv4_src=gateway['int_ip'])
        #    output_actions = [ofp_out(int_port.port_no)]

        #    self.add_flow(dp, match=input_match, actions=input_actions, idle_timeout=0)
        #    self.add_flow(dp, match=output_match, actions=output_actions, idle_timeout=0)

    def run(self, src, src_gateway, dst, dst_gateway, **kwargs):
        sdp = self.ryuapp.dps[dpid_lib.str_to_dpid(src_gateway['datapath_id'])]
        ddp = self.ryuapp.dps[dpid_lib.str_to_dpid(dst_gateway['datapath_id'])]

        sofp, sofp_parser, sofp_set, sofp_out = self.ofp_get(sdp)
        dofp, dofp_parser, dofp_set, dofp_out = self.ofp_get(ddp)

        sport = self.port_get(sdp, src['id'])
        if sport:
            smatch = sofp_parser.OFPMatch(
                    in_port=sport.port_no,
                    eth_type=ether.ETH_TYPE_IP,
                    eth_src=src['mac_address'],
                    ipv4_src=src['address'],
                    ipv4_dst=dst['address'])
            self.delete_flow(sdp, smatch)

        dport = self.port_get(ddp, dst['id'])
        if dport:
            dmatch = dofp_parser.OFPMatch(
                    in_port=dport.port_no,
                    eth_type=ether.ETH_TYPE_IP,
                    eth_src=dst['mac_address'],
                    ipv4_src=dst['address'],
                    ipv4_dst=src['address'])
            self.delete_flow(ddp, dmatch)
