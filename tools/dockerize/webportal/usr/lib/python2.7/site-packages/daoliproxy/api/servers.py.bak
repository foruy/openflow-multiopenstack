import eventlet
eventlet.monkey_patch(thread=False)

import uuid
import thread
import copy
import collections
import webob
from webob import exc
import six.moves.urllib.parse as urlparse

from oslo.config import cfg
from eventlet import greenthread

from daoliproxy.i18n import _
from daoliproxy import exception
from daoliproxy import utils
from daoliproxy import agent
from daoliproxy.api import utils as api_utils
from daoliproxy.api.user import Token
from daoliproxy.api.base import BaseController
from daoliproxy.api import common
from daoliproxy.api import vm_states
from daoliproxy.api import power_state
from daoliproxy.api.utils import local_req
from daoliproxy.api.openstack import wsgi
from daoliproxy.openstack.common import timeutils
from daoliproxy.openstack.common import jsonutils as json
from daoliproxy.openstack.common import log as logging

log_opt = cfg.StrOpt('log_prefix',
                     default='192.168',
                     help='Logical address prefix')

LOG = logging.getLogger(__name__)

CONF = cfg.CONF
CONF.register_opt(log_opt)
CONF.register_opt(cfg.IntOpt('agent_port', default=65535))
CONF.register_opt(cfg.IntOpt('flavor_count', default=2))
CONF.register_opt(cfg.IntOpt('public_port', default=5000))
CONF.register_opt(cfg.DictOpt('cidr_type'))
CONF.register_opt(cfg.IntOpt('instance_interval', default=30))

RESET_URL = 'http://www.daolicloud.com/dashboard/passwordreset'

class Controller(BaseController):
    """The servers API controller for the OpenStack API.

    zones: {zone_id: {"name": zone1, "flavor": {...}, "image": {...}}}
    """
    def __init__(self, **kwargs):
        super(Controller, self).__init__(**kwargs)
        self.init_cache()
        self.init_resource()
        self.network_types = {}

    def init_cache(self):
        # Initial user
        users = self.db.user_get_all()
        for user in users:
            self.cache_db.user_reset(user.uuid, "projects")
            self.cache_db.user_reset(user.uuid, "zones")

        # Initial project and user map
        user_projects = self.db.user_project_all()
        for up in user_projects:
            self.cache_db.user_add_project(up.user_id, up.project_id)
            self.cache_db.project_reset(up.project_id)
            self.cache_db.project_update(up.project_id, 'zone', up.zone_id)
            self.cache_db.project_update(up.project_id, 'user', up.user_id)

        # Initial instance
        servers = self.db.server_get_all()
        for server in servers:
            self.cache_db.project_add_server(server.project_id, server.id)
            self.cache_db.server_create(dict(server.iteritems()))

        # Initial Security Group
        groups = self.db.security_group_get_all()
        for group in groups:
            self.cache_db.security_group_create(
                    group.user_id, group.top, group.bottom)
            self.cache_db.security_group_create(
                    group.user_id, group.bottom, group.top)

        # Initial user from temporary
        try:
            obj = utils.load()
            for uid, zone in obj["zones"].items():
                self.cache_db.user_reset(uid, 'zones', zone)
            for pid, token in obj["tokens"].items():
                self.cache_db.project_update(pid, 'token', token)
        except IOError:
            pass

    def init_resource(self):
        self.zones = dict((zone['id'], zone) for zone 
                in self.db.zone_get_all())

        self.flavors = collections.defaultdict(list)
        for flavor in self.db.flavor_get_all():
            self.flavors[flavor['zone']].append(dict(flavor))

        self.images = collections.defaultdict(list)
        for image in self.db.image_get_all():
            self.images[image['zone']].append(dict(image))

        # Initial gateway
        self.gateways = collections.defaultdict(list)
        self._gateways = dict((g['hostname'], g)
                              for g in self.db.gateway_get_all())
        for gateway in self._gateways.values():
            self.gateways[gateway.zone].append(dict(gateway.iteritems()))

    def reload_resource(self, req):
        self.init_resource()

    def notify_about_instance(self, id, action, **kwargs):
        server = self.cache_db.server_get(id)
        user_id = self.cache_db.project_get(server['project_id'], 'user')
        self.db.notify_about_resource('instance', id, action, server['project_id'],
                                      user_id, extra=kwargs)

    def notify_about_disk(self, id, action, **kwargs):
        server = self.cache_db.server_get(id)
        user_id = self.cache_db.project_get(server['project_id'], 'user')
        self.db.notify_about_resource('disk', id, action, server['project_id'],
                                      user_id, extra=kwargs)

    def request_get(self, project_id):
        return self.cache_db.project_get(project_id, 'token')

    def preload(self, user_id):
        self.cache_db.user_reset(user_id, "projects")
        self.cache_db.user_reset(user_id, 'zones')

        user_projects = self.db.user_project_get_by_user(user_id)
        for up in user_projects:
            self.cache_db.user_add_project(up.user_id, up.project_id)
            self.cache_db.project_reset(up.project_id)
            self.cache_db.project_update(up.project_id, 'zone', up.zone_id)
            self.cache_db.project_update(up.project_id, 'user', up.user_id)

        servers = self.db.server_get_by_user(user_id)
        for server in servers:
            self.cache_db.project_add_server(server.project_id, server.id)
            self.cache_db.server_create(dict(server.iteritems()))

        groups = self.db.security_group_get_by_user(user_id)
        for group in groups:
            self.cache_db.security_group_create(
                    group.user_id, group.top, group.bottom)
            self.cache_db.security_group_create(
                    group.user_id, group.bottom, group.top)

    def _sync_user_thread(self, zid):
        users = self.db.user_get_all()
        for user in users:
            if user['username'] in utils.user_filters:
                continue
            try:
                self._register_thread(self.zones['zid'], dict(user))
            except Exception as e:
                LOG.error(e)

    def _authenticate(self, user):
        #self.preload(user['uuid'])
        self.cache_db.user_reset(user['uuid'], 'zones')
        for zone in self.zones.values():
            try:
                self._authenticate_cache(user, zone)
            except (exception.AuthorizationFailure, exception.Unauthorized):
                continue
    def _authenticate_cache(self, user, zone):
        auth_ref = utils.authentication(user['username'],
                                        user['password'],
                                        zone['auth_url'])

        projects = self.cache_db.projects_get(user['uuid'], 'projects')
        if auth_ref.project_id not in projects:
            self.db.user_project_create(user['uuid'], auth_ref.project_id,
                    auth_ref.user_id, zone["id"], zone["default_instances"])
            self.cache_db.user_update(user['uuid'], 'projects', auth_ref.project_id)
            self.cache_db.project_reset(auth_ref.project_id)
            self.cache_db.project_update(auth_ref.project_id, 'user', user['uuid'])
        
        self.cache_db.project_update(auth_ref.project_id,
            'token', Token(auth_ref, urlparse.urlparse(zone['auth_url']).hostname))
        self.cache_db.project_update(auth_ref.project_id,
            'zone', zone['id'])
        self.cache_db.user_update(user['uuid'], 'zones', zone['id'])

    @local_req
    def authenticate(self, req, body):
        auth = self._from_body(body, 'auth')
        kwargs = self._from_body(body, 'kwargs')

        if 'username' not in auth or 'password' not in auth:
            msg = _("Username or password is not exists")
            raise exc.HTTPBadRequest(explanation=msg)

        user = self.db.authenticate(auth["username"], auth["password"], **kwargs)

        if not user:
            msg = _("User is not exists")
            raise exc.HTTPBadRequest(explanation=msg)

        self.add_thread(self._authenticate, user)

        user_ref = {"uuid": user["uuid"], "username": user["username"]}

        return {'user': user_ref}

    @local_req
    def logout(self, req, body):
        user_id = self._from_body(body, 'user_id')
        if user_id:
            self.cache_db.cleanup(user_id)
        return webob.Response(status_int=202)

    @local_req
    def project_absolute_limits(self, req, id):
        limits = self.db.project_absolute_limits(id)
        return {'limits': limits}

    @local_req
    def availability_zone_list(self, req, userid):
        zones = []
        project_dict = {}
        for pid in self.cache_db.user_get(userid, 'projects', []):
            project_dict[self.cache_db.project_get(pid, 'zone')] = pid
        for zid in self.cache_db.user_get(userid, 'zones', []):
            if (project_dict.has_key(zid) and
                    self.zones.has_key(zid) and
                    not self.zones[zid]['disabled']):
                zone = self.zones[zid]
                zone["project_id"] = project_dict[zid]
                zones.append(zone)
        return {"avail_zones": zones}

    @local_req
    def flavor_list(self, req, pid):
        zone = self.cache_db.project_get(pid, 'zone')
        return {"flavors": self.flavors[str(zone)]}

    @local_req
    def image_list_detailed(self, req, pid):
        images = []
        is_public = req.GET.get('is_public')
        zone = self.cache_db.project_get(pid, 'zone')
        for image in self.images.get(zone, []):
            if image['is_public']:
                images.append(image)
        return {"images": images}

    @local_req
    def server_list(self, req, userid):
        servers = []
        projects = self.cache_db.user_get(userid, 'projects', [])
        for project in projects:
            for server in self.cache_db.project_get(project, 'servers'):
                serv = copy.deepcopy(self.cache_db.server_get(server))
                serv['status'] = common.status_from_state(serv['status'])
                servers.append(serv)

        return {"servers": servers}

    @local_req
    def server_detail(self, req, userid):
        servers = []
        user = self.db.user_info_get(userid, 'admin')
        if not user:
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)
        for serv in self.db.server_get_all():
            server = dict(serv)
            server['status'] = common.status_from_state(server['status'])
            servers.append(server)

        return {"servers": servers}

    @local_req
    def server_get(self, req, id):
        try:
            server = copy.deepcopy(self.cache_db.server_get(id))
        except KeyError:
            msg = _("Instance could not be found")
            raise exc.HTTPNotFound(explanation=msg)
        else:
            server['status'] = common.status_from_state(server['status'])

        return {'server': server}

    @local_req
    def server_delete(self, req, id):
        server = self.cache_db.server_get(id)
        if server is not None:
            try:
                agent.server_delete(self.request_get(server['project_id']), id)
            except Exception as e:
                LOG.error(e)
            self.notify_about_instance(id, 'delete')
            self.notify_about_disk(id, 'delete')
            self.db.server_delete(id)
            self.cache_db.server_delete(server['project_id'], id)

    def _server_update_thread(self, req, pid, id, image, flavor, device_map):
        try_count = 500
        while try_count > 0:
            try_count = try_count - 1
            server = agent.server_get(self.request_get(pid), id)
            if server and server.status.lower() in (vm_states.ACTIVE, vm_states.ERROR):
                serv = self._format_server(server)
                self.cache_db.server_update(id, serv)
                self.db.server_update(id, serv)
                if server.status.lower() == vm_states.ACTIVE:
                    #user = self.cache_db.project_get(pid, 'user')
                    zone = self.cache_db.project_get(pid, 'zone')
                    image_dict = dict((img['id'], img['property'])
                        for img in self.images.get(zone, []))
                    firewall = {'instance_id': id, 'hostname': serv['host']}
                    for port in image_dict.get(image, []):
                        gateway = self.db.gateway_count(serv['host'])
                        firewall['gateway_port'] = gateway.count
                        firewall['service_port'] = port
                        self._firewall_create(req, firewall)
                    self.notify_about_instance(id, 'create', flavor=flavor)
                    if device_map:
                        self.notify_about_disk(id, 'create', device_map=device_map)
                else:
                    self.notify_about_instance(id, 'error')
                break
            else:
                greenthread.sleep(2)

    @local_req
    def server_start(self, req, id, body):
        server = self.cache_db.server_get(id)
        if not timeutils.is_older_than(
                server['updated_at'], CONF.instance_interval):
            msg = _("Your operation is too frequent. Please try again later.")
            raise exc.HTTPLocked(explanation=msg)
        try:
            agent.server_start(self.request_get(server['project_id']), id)
        except exception.Conflict as e:
            LOG.error(e)
        update_time = timeutils.utcnow()
        status = {'status': vm_states.ACTIVE,
                  'power_state': power_state.RUNNING,
                  'updated_at': update_time}
        self.db.server_update(id, status)
        self.cache_db.server_update(id, status)
        self.notify_about_instance(id, 'start')

    @local_req
    def server_stop(self, req, id, body):
        server = self.cache_db.server_get(id)
        if not timeutils.is_older_than(
                server['updated_at'], CONF.instance_interval):
            msg = _("Your operation is too frequent. Please try again later.")
            raise exc.HTTPLocked(explanation=msg)
        try:
            agent.server_stop(self.request_get(server['project_id']), id)
        except exception.Conflict as e:
            LOG.error(e)
        update_time = timeutils.utcnow()
        status = {'status': vm_states.STOPPED,
                  'power_state': power_state.SHUTDOWN,
                  'updated_at': update_time}
        self.db.server_update(id, status)
        self.cache_db.server_update(id, status)
        self.notify_about_instance(id, 'stop')

    @local_req
    def server_create(self, req, id, body):
        all_server = []
        server = self._from_body(body, 'server')
        kwargs = self._from_body(body, 'kwargs')

        limit = self.db.project_absolute_limits(id)
        if (limit["maxTotalInstances"] - limit["totalInstancesUsed"]
                                       - kwargs['instance_count'] < 0):
            msg = _("Quota exceeded.")
            raise exc.HTTPBadRequest(explanation=msg)

        zone_id = self.cache_db.project_get(id, 'zone')
        if not self.zones.get(zone_id):
            msg = _("Zone not found.")
            raise exc.HTTPBadRequest(explanation=msg)

        count = kwargs['instance_count']
        image_id = server['image']
        device_mapping_v2 = kwargs.get("block_device_mapping_v2")

        if image_id is None and device_mapping_v2:
            for device in device_mapping_v2:
                if device["source_type"] == "image":
                    image_id = device["uuid"]
                    break

        if image_id is None:
            msg = _("You must select an image.")
            raise exc.HTTPBadRequest(explanation=msg)

        for i in range(count):
            kwargs['instance_count'] = 1
            user = self.cache_db.project_get(id, 'user')
            try:
                net_type = kwargs.pop('net_type')
                self.network_types[user] = net_type
            except KeyError:
                msg = _("You must select a network type.")
                raise exc.HTTPBadRequest(explanation=msg)
            if not kwargs.get('accessIPv4', None):
                #network = self.db.network_count(user)
                #kwargs['accessIPv4'] = '%s.%s.%s' % (
                #    CONF.log_prefix, network.third, network.fourth)
                while True:
                    ip_address = self.db.generate_ip(user, net_type)
                    if not ip_address:
                        msg = _("All IPs allocated")
                        raise exc.HTTPConflict(explanation=msg)
                    if not self.db.network_get_by_project(user, ip_address):
                        kwargs['accessIPv4'] = ip_address
                        break
            else:
                _server = self.db.network_get_by_project(user, kwargs['accessIPv4'])
                if _server:
                    msg = _("This address is be in used")
                    raise exc.HTTPConflict(explanation=msg)

            name = '%s%s' % (server['name'], kwargs['accessIPv4'].replace('.', '-'))

            serv = agent.server_create(self.request_get(id),
                server['name'], server['image'], server['flavor'], **kwargs)

            self.add_thread(self._server_update_thread, req, id, serv.id, image_id,
                            server['flavor'], device_mapping_v2)
            _server = {'id': serv.id,
                       'name': (name if count > 1 else server['name']),
                       'availability_zone': zone_id,
                       'project_id': id,
                       'user_id': user,
                       'address': kwargs['accessIPv4'],
                       'image': image_id,
                       'flavor': server['flavor'],
                       'status': vm_states.BUILDING,
                       'updated_at': timeutils.utcnow(),
            }
            all_server.append(_server)
            self.db.server_create(_server)
            self.cache_db.project_add_server(id, serv.id)
            self.cache_db.server_create(_server)

        return {'server': {'servers': all_server}}

    def _format_server(self, serv, **kwargs):
        server = {}
        server["id"] = serv.id
        if serv.addresses.values():
            net = serv.addresses.values()[0][0]
            address = net['addr']
            mac_address = net.get('OS-EXT-IPS-MAC:mac_addr')
        else:
            address = None
            mac_address = None
        server["address"] = address
        server["mac_address"] = mac_address
        server["project_id"] = serv.tenant_id
        server["phy_ipv4"] = serv.phy_ipv4
        try:
            # Deprecated
            server["host"] = serv.gateway
        except:
            server["host"] = getattr(serv, 'OS-EXT-SRV-ATTR:host')
        server["fake_hostname"] = server["host"]
        server["status"] = serv.status.lower()
        server["power_state"] = getattr(serv, 'OS-EXT-STS:power_state')
        server["created_at"] = timeutils.strtime(timeutils.parse_isotime(serv.created))
        server.update(kwargs)

        return server

    @local_req
    def server_network(self, req, id, body):
        network = self._from_body(body, 'network')
        address = self._from_body(network, 'address')
        server = self.db.network_get_by_project(id, address)
        if server:
            msg = _("This address is be in used")
            raise exc.HTTPConflict(explanation=msg)

    @local_req
    def firewall_get(self, req, id):
        firewall = self.db.firewall_get_by_instance(id)
        return {'firewall': [dict(fw.iteritems()) for fw in firewall]}

    @local_req
    def firewall_delete(self, req, fid):
        firewall = self.db.firewall_get(id=fid)
        if not firewall:
            msg = _('The firewall could not be found.')
            raise exc.HTTPNotFound(explanation=msg)
        instance_id, firewall_id = fid.split('_')
        server = self.cache_db.server_get(instance_id)
        #if not firewall['fake_zone']:
        #    zone = self._gateways[firewall['hostname']]['zone']
        #    data = {'action': 'delete', 'server': server, 'firewall': firewall}
        #    o = urlparse.urlparse(self.zones[zone]['auth_url'])
        #    self.client.set_management_url(self._build_url(
        #            o.netloc.split(':')[0], CONF.agent_port))
        #    self.client.put('/firewall', body=data)

        agent.firewall_delete(self.request_get(server['project_id']), firewall_id)
        self.db.firewall_delete(fid)
        return webob.Response(status_int=202)

    @local_req
    def firewall_exist(self, req, id, body):
        firewall = self._from_body(body, 'firewall')
        firewall_ref = self.db.firewall_get(hostname=firewall['hostname'],
                                            gateway_port=firewall['gateway_port'])
        return {'firewall': firewall_ref}

    @local_req
    def firewall_create(self, req, body):
        firewall = self._from_body(body, 'firewall')
        return self._firewall_create(req, firewall)

    def _firewall_create(self, req, firewall):
        server = self.cache_db.server_get(firewall['instance_id'])
        server_zone = self._gateways[server['host']]['zone']
        firewall_zone = self._gateways[firewall['hostname']]['zone']
        firewall['fake_zone'] =  (server_zone == firewall_zone)
        #if not firewall['fake_zone']:
        #    data = {'action': 'create', 'server': server, 'firewall': firewall}
        #    o = urlparse.urlparse(self.zones[firewall_zone]['auth_url'])
        #    self.client.set_management_url(self._build_url(
        #            o.netloc.split(':')[0], CONF.agent_port))
        #    self.client.put('/firewall', body=data)

        nfirewall = agent.firewall_create(
            self.request_get(server['project_id']), **firewall)._info
        nfirewall['id'] = '%s_%s' % (nfirewall['instance_id'], nfirewall['id'])

        self.db.firewall_create(nfirewall)
        return {'firewall': nfirewall}

    @local_req
    def security_group_list(self, req, id):
        security_groups = self.cache_db.security_group_list(id)
        return {'security_groups': security_groups}

    @local_req
    def security_group_update(self, req, id, body):
        security_group = self._from_body(body, 'security_group')

        top = self.cache_db.server_get(security_group['top'])
        bottom = self.cache_db.server_get(security_group['bottom'])

        def _wrapper(src, dst):
            data = {"kwargs": {'src': src, 'dst': dst}}
            zone = self.cache_db.project_get(src['project_id'], 'zone')
            o = urlparse.urlparse(self.zones[zone]['auth_url'])
            stack_url = self._build_url(o.netloc.split(':')[0], CONF.agent_port)
            self.client.set_management_url(stack_url)
            self.client.put('/group/delete', body=data)

        if top["project_id"] == bottom["project_id"]:
            agent.security_group_update(self.request_get(top["project_id"]),
                top["project_id"], **security_group)

        if security_group['action'] == 'create':
            self.db.security_group_create(
                id, security_group['top'], security_group['bottom'])
            self.cache_db.security_group_create(id, top['id'], bottom['id'])
        elif security_group['action'] == 'delete':
            self.db.security_group_delete(
                id, security_group['top'], security_group['bottom'])
            self.cache_db.security_group_delete(id, top['id'], bottom['id'])
            if top["project_id"] != bottom["project_id"]:
                _wrapper(top, bottom)
                _wrapper(bottom, top)

    @local_req
    def gateway_list(self, req):
        gateways = []
        for zone, gateway in self.gateways.items():
            gateways.extend(gateway)
        return {'gateways': gateways}

    @local_req
    def gateway_get(self, req, body):
        hostname = self._from_body(body, "hostname")
        gateway = self._gateways[hostname]
        return {'gateway': gateway}

    @local_req
    def gateway_get_by_instance(self, req, id):
        server = self.cache_db.server_get(id)
        zone = self.cache_db.project_get(server['project_id'], 'zone')
        gateways = self.gateways.get(zone, [])
        return {'gateways': gateways}

    @local_req
    def gateway_update(self, req, id, body):
        gateway = self._from_body(body, 'gateway')
        server = self.cache_db.server_get(id)
        old_hostname = gateway['old_gateway']
        new_hostname = gateway['new_gateway']
        old_gateway = self._gateways[old_hostname]
        new_gateway = self._gateways[new_hostname]

        if old_hostname != new_hostname:
            #if old_gateway['idc_id'] == new_gateway['idc_id']:
            #    address = new_gateway['int_ip']
            #else:
            #    address = new_gateway['ext_ip']
            #    #msg = _("Don't match the host (%s)." % new_hostname)
            #    #raise exc.HTTPBadRequest(explanation=msg)
            _gateway = {'fake_hostname': new_hostname,
                        'fake_zone': old_gateway['zone']==new_gateway['zone']}
            agent.gateway_update(self.request_get(server['project_id']),
                                 id, old_hostname, _gateway)
            hostname = {'fake_hostname': new_hostname}
            self.db.server_update(id, hostname)
            self.cache_db.server_update(id, hostname)
        return webob.Response(status=202)

    def _format_user(self, user):
        return {'id': user.uuid,
                'username': user.username,
                'email': user.email,
                'phone': user.phone,
                'company': user.company,
                'created_at': user.created_at,
                'updated_at': user.updated_at,
        }

    @local_req
    def user_list(self, req, id):
        if not self.db.user_info_get(id, 'admin'):
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)

        users = [self._format_user(user) for user in self.db.user_get_all()]

        return {'users': users}

    @local_req
    def user_get(self, req, id):
        user = self._user_format(self.db.user_get(id))
        return {'user': user}

    def _register_thread(self, request, auth):
        def _register_try(func, **kwargs):
            try_count = 3
            while try_count > 0:
                try_count -= 1
                try:
                    return func(request, **kwargs)
                except Exception as e:
                    LOG.error(e)
                    greenthread.sleep(2)

            if try_count <= 0:
                # Store database on error
                auth['method'] = func.__name__
                auth['auth_url'] = request['auth_url']
                self.db.user_task('register', json.dumps(auth))
                raise Exception('User "%s" on "%s" register failed.' % (
                    auth['username'], request['auth_url']))

        obj = _register_try(agent.tenant_create, name=auth['username'],
                description='%s tenant' % auth['username'], enabled=True)
        _register_try(agent.user_create, name=auth['username'], email=auth['email'],
                password=auth['password'], project=obj.id, enabled=True)
        LOG.debug('User "%s" on "%s" register successful' % (
            auth['username'], request['auth_url']))

    def _send_mail(self, auth):
        try_count = 2
        while try_count > 0:
            try_count -= 1
            try:
                return api_utils.register_sendmail(auth)
            except Exception as e:
                LOG.error(e)
                greenthread.sleep(2)

        if try_count <= 0:
            self.db.user_task('sendmail', json.dumps(auth))
            raise Exception('User "%s" send email failed.' % args[0])

    @local_req
    def register(self, req, body):
        auth = self._from_body(body, 'auth')
        if auth['username'] in utils.user_filters or \
                self.db.checkdata('username', auth['username']):
            msg = _('The username "%s" is already in used.' % auth['username'])
            raise exc.HTTPConflict(explanation=msg)

        if 'password' not in auth or not auth['password']:
            auth['password'] = api_utils.create_password()

        user = self.db.register(username=auth['username'], password=auth['password'],
                                email=auth['email'], type=auth['type'], phone=auth['phone'],
                                company=auth['company'], reason=auth['reason'])
        self.add_thread(self._send_mail, auth)

        LOG.debug('User %s[%s] send successfully!' % (auth['username'], auth['email']))
        for zone in self.zones.values():
            self.add_thread(self._register_thread, zone, auth)
        self.cache_db.user_reset(user.uuid, "projects")
        try:
            from bill import api as bill_api
            bill_api.register_project(user.uuid)
        except Exception as e:
            LOG.error(e)
        return {'auth': {'name': auth['username']}}

    @local_req
    def checkdata(self, req, body):
        data = self._from_body(body, 'check')
        for key, val in data.items():
            if (key == 'username' and val in utils.user_filters) or \
                    self.db.checkdata(key, val):
                msg = _('The %s "%s" is already in used.' % (key, val))
                raise exc.HTTPConflict(explanation=msg)

    @local_req
    def validate_user(self, req, body):
        user = self._from_body(body, 'user')
        if not self.db.validate_user(user):
            msg = _('The user "%s" does not match.' % user.get('username'))
            raise exc.HTTPNotFound(explanation=msg)

    @local_req
    def update_user_key(self, req, body):
        user = self._from_body(body, 'user')
        user_obj = self.db.update_user(
                user['base'], extra={'key': user['kwargs']['key']})

        url = "%s?uid=%s&username=%s&email=%s&tid=%s" % (RESET_URL,
                user_obj.uuid, username, email, user['kwargs']['key'])
        data = {'email': user['base']['email'],
                'subject': '[Daolicloud] Reset your password!',
                'body': 'Please Click URL: %s' % url,
        }
        send_mail([data])
        #send_mail()
        return webob.Response(status=202)

    @local_req
    def getpassword(self, req, body):
        user = self._from_body(body, 'user')
        self._getpassword(user['base'], user['kwargs']['key'])
        return webob.Response(status=202)

    def _getpassword(self, user, key):
        user_obj = self.db.validate_user(user)

        if not user_obj:
            msg = _("User not found.")
            raise exc.HTTPNotFound(explanation=msg)

        if not user_obj['extra'] or key != user_obj['extra']['key']:
            msg = _("Request expired.")
            raise exc.HTTPForbidden(msg)

    @local_req
    def resetpassword(self, req, body):
        user = self._from_body(body, 'user')
        self._getpassword(user['base'], user['kwargs']['key'])
        password = user['kwargs']['password']
        user_obj = self.db.update_user(
                user['base'], password=password, extra={})
        user_projects = self.db.user_project_get_by_user(user_obj.uuid)
        for up in user_projects:
            if self.zones.has_key(up.zone_id):
                agent.user_update_password(
                        self.zones[up.zone_id], user['base']['uuid'], password)
        return webob.Response(status=202)

    @local_req
    def monitor(self, req, id):
        server = self.cache_db.server_get(id)
        if not server:
            msg = 'Instance (%s) could not be found.'
            raise exception.InstanceNotFound(msg % id)
        gateway = self._gateways[server['host']]
        if not gateway:
            msg = 'Gateway (%s) could not be found.'
            raise exception.InstanceNotFound(msg % server['host'])
        monitor_path = 'containers/docker/nova-%s' % id
        monitor_url = self._build_url(gateway['ext_ip'], 8088, monitor_path)
        return {'monitor': {'monitor_url': monitor_url}}

    @local_req
    def user_login_list(self, req, id):
        if not self.db.user_info_get(id, 'admin'):
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)
        user = self.db.user_login_list()
        return {'user': [dict(u) for u in user]}

    @local_req
    def user_login_detail(self, req, id):
        user = self.db.user_login_list(user_id=id)
        return {'user': [dict(u) for u in user]}

    def _format_image(self, image):
        _image = {}
        _image['id'] = image.id
        _image['name'] = image.name
        _image['checksum'] = image.checksum
        _image['container_format'] = image.container_format
        _image['disk_format'] = getattr(image, 'disk_format', 'raw')
        _image['is_public'] = image.is_public
        _image['min_disk'] = image.min_disk
        _image['min_ram'] = image.min_disk
        _image['size'] = image.size
        _image['owner'] = image.owner
        _image['status'] = image.status
        _image['property'] = [22]
        if _image['container_format'] == 'docker':
            try:
                display_format = image.name.split('-')[1].replace('.', '')
            except IndexError:
                display_format = None
            if display_format == 'wordpress':
                _image['property'].append(80)
            _image['display_format'] = display_format
        return _image

    @local_req
    def image_list(self, req):
        return {'images': self.images.values()}

    @local_req
    def image_get(self, req, id):
        return {'images': self.images.get(id, [])}

    @local_req
    def image_create(self, req, zone, body):
        _image = self._from_body(body, 'image')
        image = self.db.image_create(zone, _image)
        self.images[zone].append(image)
        return {'image': image}

    @local_req
    def image_delete(self, req, id):
        self.db.image_delete(id)

    @local_req
    def image_rebuild(self, req, body):
        project_dict = {}
        userid = self._from_body(body, 'user_id')
        zone = body.get('zone', None)
        for pid in self.cache_db.user_get(userid, 'projects', []):
            project_dict[self.cache_db.project_get(pid, 'zone')] = pid
        self.db.image_delete(zone=zone)
        if zone is None:
            zones = self.cache_db.user_get(userid, 'zones', [])
        else:
            zones = [zone]
        for zid in zones:
            self.images[zid] = []
            images, has_more = agent.image_list_detailed(
                    self.request_get(project_dict[zid]))
            for image in images:
                self.images[zid].append(self.db.image_create(
                    zid, self._format_image(image)))

    @local_req
    def zone_create(self, req, body):
        user_id = self._from_body(body, 'user_id')
        zone = self._from_body(body, 'zone')
        user = self.db.user_info_get(user_id, 'admin')
        if not user:
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)
        zone_ref = self.db.zone_create(zone)
        self._authenticate_cache(user, zone_ref)
        self.zones[zone_ref.id] = dict(zone_ref)
        self.add_thread(self._sync_user_thread, zone_ref.id)
        return {'zone': zone_ref}

    @local_req
    def zone_delete(self, req, id):
        self.db.zone_delete(id)
        self.db.image_delete(zone=id)
        self.images.pop(id, None)
        self.db.flavor_delete(zone=id)
        self.flavors.pop(id, None)
        self.db.gateway_delete(zone=id)
        self.gateways.pop(id, None)
        self.zones.pop(id, None)
        return webob.Response(status_int=202)

    def _format_flavor(self, flavor):
        _flavor = {}
        _flavor['flavorid'] = flavor.id
        _flavor['name'] = flavor.name
        _flavor['vcpus'] = flavor.vcpus
        _flavor['ram'] = flavor.ram
        _flavor['disk'] = flavor.disk
        _flavor['swap'] = flavor.swap
        _flavor['ephemeral'] = getattr(flavor,
            'OS-FLV-EXT-DATA:ephemeral', 0)
        _flavor['rxtx_factor'] = flavor.rxtx_factor
        _flavor['is_public'] = getattr(flavor,
            'os-flavor-access:is_public', True)
        return _flavor

    @local_req
    def flavor_get_by_zone(self, req, id):
        return {'flavors': self.flavors.get(id, [])}

    @local_req
    def flavor_create(self, req, zone, body):
        _flavor = self._from_body(body, 'flavor')
        flavor = self.db.flavor_create(zone, _flavor)
        self.flavors[zone].append(flavor)
        return {'flavor': flavor}

    @local_req
    def flavor_delete(self, req, id):
        self.db.flavor_delete(id)

    @local_req
    def flavor_rebuild(self, req, body):
        project_dict = {}
        userid = self._from_body(body, 'user_id')
        zone = body.get('zone', None)
        for pid in self.cache_db.user_get(userid, 'projects', []):
            project_dict[self.cache_db.project_get(pid, 'zone')] = pid
        self.db.flavor_delete(zone=zone)
        if zone is None:
            zones = self.cache_db.user_get(userid, 'zones', [])
        else:
            zones = [zone]
        for zid in zones:
            self.flavors[zid] = []
            flavors = agent.flavor_list(
                    self.request_get(project_dict[zid]))
            if len(flavors) > CONF.flavor_count:
                flavors = flavors[:CONF.flavor_count]
            for flavor in flavors:
                self.flavors[zid].append(self.db.flavor_create(
                    zid, self._format_flavor(flavor)))

    def _format_gateway(self, gateway):
        _gateway = {}
        _gateway['hostname'] = gateway.hostname
        _gateway['int_ip'] = gateway.addr
        _gateway['ext_ip'] = gateway.extaddr
        _gateway['mac_address'] = gateway.intmac
        _gateway['idc_id'] = gateway.idc_id
        return _gateway

    @local_req
    def gateway_get_by_zone(self, req, id):
        return {'gateways': self.gateways.get(id, [])}

    @local_req
    def gateway_create(self, req, zone, body):
        _gateway = self._from_body(body, 'gateway')
        gateway = self.db.gateway_create(zone, _gateway)
        self._gateways[gateway['hostname']] = gateway
        self.gateways[zone].append(gateway)
        return {'gateway': gateway}

    @local_req
    def gateway_delete(self, req, id):
        self.db.gateway_delete(id)

    @local_req
    def gateway_rebuild(self, req, body):
        project_dict = {}
        userid = self._from_body(body, 'user_id')
        zone = body.get('zone', None)
        for pid in self.cache_db.user_get(userid, 'projects', []):
            project_dict[self.cache_db.project_get(pid, 'zone')] = pid
        self.db.gateway_delete(zone=zone)
        if zone is None:
            zones = self.cache_db.user_get(userid, 'zones', [])
        else:
            zones = [zone]
        for zid in zones:
            self.gateways[zid] = []
            gateways = agent.gateway_list(
                    self.request_get(project_dict[zid]))
            for gateway in gateways:
                _gateway = self.db.gateway_create(
                    zid, self._format_gateway(gateway))
                self._gateways[_gateway['hostname']] = _gateway
                self.gateways[zid].append(_gateway)

    @local_req
    def get_last_network_type(self, req, id):
        net_type = self.network_types.get(id, 1)
        return {'netype': {'net_type': net_type}}

    def consume(self, start, end):
        start_time = start.created_at
        delete_time = None
        if end is None:
            if start.action == 'delete':
                end_time = start.created_at
                delete_time = end_time
            else:
                end_time = timeutils.utcnow()
        else:
            end_time = end.created_at
            if end.action == 'delete':
                delete_time = end_time
        return (start_time, end_time, delete_time)

    def _format_resource(self, source):
        src = dict(source[0], usage=0, deleted_at=timeutils.utcnow())
        if src['action'] == 'create':
            if len(source) % 2 != 0:
                source.append(None)
            for i in xrange(0, len(source), 2):
                start_time, end_time, delete_time = self.consume(
                    source[i], source[i+1])
                src['usage'] += timeutils.delta_seconds(start_time, end_time)
                if delete_time is not None:
                    src['deleted_at'] = delete_time
            return src

    @local_req
    def resource_list(self, req, id):
        resources = []
        sources = collections.defaultdict(dict)
        for res in self.db.resource_get(user_id=id):
            if not sources[res.source_id].has_key(res.source_name):
                sources[res.source_id][res.source_name] = []
            sources[res.source_id][res.source_name].append(res)
        for sid, src in sources.items():
            if src.has_key('instance'):
                r = self._format_resource(src['instance'])
                if r: resources.append(r)
            if src.has_key('disk'):
                r = self._format_resource(src['disk'])
                if r: resources.append(r)
        return {'resources': resources}

    @local_req
    def resource_get(self, req, id):
        source_id = req.GET.get('source_id', None)
        source_name = req.GET.get('source_name', None)
        resources = self.db.resource_get(
            source_id=source_id, source_name=source_name, user_id=id)
        return {'resources': resources}

    @local_req
    def user_get_by_time(self, req, id):
        start_time = req.GET.get('start_time', None)
        end_time = req.GET.get('end_time', None)
        user = self.db.user_info_get(id, 'admin')
        if not user:
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)
        return {'users': self.db.user_get_by_time(start_time, end_time)}

    def gateway_wrap(self, server):
        if server is not None:
            gateway = self._gateways.get(server['host'], None)
            if gateway is not None:
                server['uuid'] = server['id']
                server['idc_id'] = gateway['idc_id']
                server['ext_ip'] = gateway['ext_ip']
                server['gateway_ip'] = gateway['int_ip']
                server['gateway_mac'] = gateway['mac_address']
            else:
                server = None
        return server

    def server_get_by_key(self, req, project, body):
        """Get server by source mac and destination ip."""
        address = self._from_body(body, 'nw_dst')
        id = self._from_body(body, 'src_id')
        has_more, _server = self.cache_db.server_get_by_key(project, id, address)
        server = self.gateway_wrap(_server)
        return {'server': {'has_more': has_more, 'server': server}}

    def server_get_by_id(self, req, sid, did):
        """Get server by uuid."""
        server = {}
        msg = 'Instance (%s) could not be found.'
        _server = self.cache_db.server_get(sid)
        if not _server:
            raise exception.InstanceNotFound(msg % sid)
        server['src'] = self.gateway_wrap(_server)
        _server = self.cache_db.server_get(did)
        if not _server:
            raise exception.InstanceNotFound(msg % did)
        server['dst'] = self.gateway_wrap(_server)
        return {'servers': server}

def create_resource():
    return wsgi.Resource(Controller())
