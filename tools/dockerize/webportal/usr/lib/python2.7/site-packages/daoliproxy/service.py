"""Generic Node base class for all workers that run on hosts."""

import random

from oslo.config import cfg

from daoliproxy.i18n import _
from daoliproxy.openstack.common import importutils
from daoliproxy.openstack.common import log as logging
from daoliproxy.openstack.common import service
from daoliproxy.openstack.common import threadgroup
from daoliproxy import wsgi
from daoliproxy.api.router import APIRouter

LOG = logging.getLogger(__name__)

service_opts = [
    cfg.IntOpt('report_interval',
               default=10,
               help='Seconds between nodes reporting state to datastore'),
    cfg.BoolOpt('periodic_enable',
               default=True,
               help='Enable periodic tasks'),
    cfg.IntOpt('periodic_fuzzy_delay',
               default=60,
               help='Range of seconds to randomly delay when starting the'
                    ' periodic task scheduler to reduce stampeding.'
                    ' (Disable by setting to 0)'),
    cfg.StrOpt('daoliproxy_listen',
               default="0.0.0.0",
               help='The IP address on which the metadata API will listen.'),
    cfg.IntOpt('daoliproxy_listen_port',
               default=65534,
               help='The port on which the metadata API will listen.'),
    cfg.IntOpt('daoliproxy_workers',
               help='Number of workers for metadata service. The default will '
                    'be the number of CPUs available.'),
    cfg.StrOpt('daoliproxy_manager',
               default='daoliproxy.manager.ProxyManager',
               help='Full class name for the Manager for compute'),
]

CONF = cfg.CONF
CONF.register_opts(service_opts)

class WSGIService(object):
    """Provides ability to launch API from a 'paste' configuration."""

    def __init__(self, name, loader=None, use_ssl=False, max_url_len=None):
        """Initialize, but do not start the WSGI server.

        :param name: The name of the WSGI server given to the loader.
        :param loader: Loads the WSGI application using the given name.
        :returns: None

        """
        self.name = name
        self.manager = self._get_manager()
        #self.loader = loader or wsgi.Loader()
        #self.app = self.loader.load_app(name)
        self.app = APIRouter()
        self.host = getattr(CONF, '%s_listen' % name, "0.0.0.0")
        self.port = getattr(CONF, '%s_listen_port' % name, 0)
        self.workers = getattr(CONF, '%s_workers' % name, None)
        if self.workers < 1:
            LOG.warn(_("Value of config option %(name)s_workers must be "
                       "integer greater than 1.  Input value ignored.") %
                     {'name': name})
            # Reset workers to default
            self.workers = None
        self.use_ssl = use_ssl
        self.server = wsgi.Server(name,
                                  self.app,
                                  host=self.host,
                                  port=self.port,
                                  use_ssl=self.use_ssl,
                                  max_url_len=max_url_len)
        # Pull back actual port used
        self.port = self.server.port
        self.backdoor_port = None

        self.tg = threadgroup.ThreadGroup(1000)

    def reset(self):
        """Reset server greenpool size to default.

        :returns: None
        """
        self.server.reset()

    def _get_manager(self):
        """Initialize a Manager object appropriate for this service.

        Use the service name to look up a Manager subclass from the
        configuration and initialize an instance. If no class name
        is configured, just return None.

        :returns: a Manager instance, or None.

        """
        fl = '%s_manager' % self.name
        if fl not in CONF:
            return None

        manager_class_name = CONF.get(fl, None)
        if not manager_class_name:
            return None

        manager_class = importutils.import_class(manager_class_name)
        return manager_class()

    def start(self):
        """Start serving this service using loaded configuration.

        Also, retrieve updated port number in case '0' was passed in, which
        indicates a random port should be used.

        :returns: None

        """
        if self.manager:
            self.manager.init_host()
            self.manager.pre_start_hook()
            if self.backdoor_port is not None:
                self.manager.backdoor_port = self.backdoor_port
        self.server.start()
        if self.manager:
            self.manager.post_start_hook()

            if CONF.get('periodic_fuzzy_delay'):
                initial_delay = random.randint(0, CONF.periodic_fuzzy_delay)
            else:
                initial_delay = None

            self.tg.add_dynamic_timer(self.manager.periodic_tasks,
                                      initial_delay=initial_delay,
                                      periodic_interval_max=60)

    def _stop(self):
        from daoliproxy.db.base import MDB as cache
        cache.user_save()

    def stop(self):
        """Stop serving this API.

        :returns: None
        """
        self._stop()
        self.server.stop()

        if self.manager:
            self.manager.cleanup_host()
        self.tg.stop()
        self.tg.wait()

    def wait(self):
        """Wait for the service to stop serving this API.

        :returns: None
        """
        self.server.wait()

def process_launcher():
    return service.ProcessLauncher()
