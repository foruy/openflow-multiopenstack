import eventlet
eventlet.monkey_patch(thread=False)

import os
import uuid
import thread
import copy
import collections
import webob
from webob import exc
from six.moves.urllib import parse

from oslo.config import cfg
from eventlet import greenthread

from daoliproxy.i18n import _
from daoliproxy import exception
from daoliproxy import utils
from daoliproxy import agent
from daoliproxy.api import utils as api_utils
from daoliproxy.api.user import Token
from daoliproxy.api.base import BaseController
from daoliproxy.api import common
from daoliproxy.api import vm_states
from daoliproxy.api import power_state
from daoliproxy.api.utils import local_req
from daoliproxy.api.openstack import wsgi
from daoliproxy.linux.network import Network
from daoliproxy.openstack.common import timeutils
from daoliproxy.openstack.common import jsonutils as json
from daoliproxy.openstack.common import log as logging

LOG = logging.getLogger(__name__)

idc_opts = [
    cfg.IntOpt('idc_id',
               default=os.environ.get('idc_id', 0),
               help="Default idc identification"),
    cfg.StrOpt('topic', default='webproxy',
               help="The server topic name"),
    cfg.StrOpt('controller_url',
               default='http://127.0.0.1:8081',
               help="The openflow controller url")
]

quota_opts = [
    cfg.IntOpt('flavor_count', default=2,
               help="Default falvor number for zone"),
    cfg.IntOpt('instance_count', default=10,
               help="Default instance number for user"),
]

CONF = cfg.CONF
CONF.import_opt('agent_port', 'daoliproxy.manager')
CONF.import_opt('host', 'daoliproxy.netconf')
CONF.import_opt('my_ip', 'daoliproxy.netconf')
CONF.register_opts(idc_opts)
CONF.register_opts(quota_opts)
CONF.register_opt(cfg.IntOpt('admin_port', default=35357))
CONF.register_opt(cfg.IntOpt('instance_interval', default=30))

# CIDR = {1: '192.168.0.0/16', 2: '172.16.0.0/12', 3: '10.0.0.0/8'}
#CONF.register_opt(cfg.DictOpt('cidr_type', default=CIDR))

class Controller(BaseController):
    """The servers API controller for the DaoliProxy API.

    Including instances, disks, zones, images, flavors, gateways, etc. resources.
    """
    def __init__(self, **kwargs):
        super(Controller, self).__init__(**kwargs)
        self.cache_db.user_load()
        #self.network_types = {}

    def notify_about_instance(self, id, action, server=None, **kwargs):
        if server is None:
            server = self.db.server_get(id)
        if kwargs.has_key('flavor'):
            kwargs['flavor'] = self.db.flavor_get(kwargs['flavor'])
        self.db.notify_about_resource('instance', id, action, server['project_id'],
                                      server['user_id'], extra=kwargs)

    def notify_about_disk(self, id, action, server=None, **kwargs):
        if server is None:
            server = self.db.server_get(id)
        self.db.notify_about_resource('disk', id, action, server['project_id'],
                                      server['user_id'], extra=kwargs)

    def request_get(self, project_id=None, instance_id=None):
        if project_id is None:
            if instance_id is not None:
                server = self.db.server_get(instance_id)
                project_id = server['project_id']
            else:
                msg = _("Instance could not be found.")
                raise exc.HTTPNotFound(explanation=msg)

        return self.cache_db.project_get(project_id)

    def _sync_user_thread(self, request):
        users = self.db.user_get_all()
        for user in users:
            if user['username'] in utils.user_filters:
                continue
            try:
                self._register_thread(request, user, check=False)
            except Exception as e:
                LOG.error(e)

    def _authenticate(self, user):
        self.cache_db.user_reset(user['uuid'])
        for zone in self.db.zone_get_all():
            if zone['disabled']:
                continue
            try:
                self._authenticate_cache(user, zone)
            except (exception.AuthorizationFailure, exception.Unauthorized) as e:
                print e
                continue

    def _authenticate_cache(self, user, zone):
        auth_ref = utils.authentication(user['username'],
                                        user['password'],
                                        zone['auth_url'])
        projects = [u.project_id for u in
                    self.db.user_project_get_by_user(user['uuid'])]

        if auth_ref.project_id not in projects:
            self.db.user_project_create(user['uuid'], auth_ref.project_id,
                auth_ref.user_id, zone["id"], zone["default_instances"])

        host = utils.urlparse.urlparse(zone['auth_url']).hostname

        self.cache_db.project_update(auth_ref.project_id, Token(auth_ref, host))
        self.cache_db.user_update(user['uuid'], zone['id'])

    @local_req
    def authenticate(self, req, body):
        auth = self._from_body(body, 'auth')
        kwargs = body.get('kwargs', {})
        if not kwargs:
            kwargs['user_type'] = req.user_agent
            kwargs['user_addr'] = req.client_addr

        if 'username' not in auth or 'password' not in auth:
            msg = _("Username or password is not exists")
            raise exc.HTTPBadRequest(explanation=msg)

        user = self.db.authenticate(auth["username"], auth["password"], **kwargs)

        if not user:
            msg = _("User is not exists")
            raise exc.HTTPBadRequest(explanation=msg)

        #self.add_thread(self._authenticate, user)
        self.cache_db.user_reset(user['uuid'])

        return {'user': self._format_user(user)}

    @local_req
    def authenticate_by_zone(self, req, userid, body):
        self._authenticate_by_zone(req, userid, body)

    def authenticate_by_zone_proxy(self, req, userid, body):
        return self._authenticate_by_zone(req, userid, body, check=False)

    def _authenticate_by_zone(self, req, userid, body, check=True):
        zone = self.db.zone_get(self._from_body(body, 'zone_id'))

        if not zone or zone['disabled']:
            msg = _("Zone could not be found or disabled.")
            raise exc.HTTPBadRequest(explanation=msg)

        user = self.db.user_get(userid)

        if not user:
            msg = _("The user could not be found.")
            raise exc.HTTPNotFound(explanation=msg)

        # proxy -> authenticate_by_zone_proxy
        if check and zone.idc_id != CONF.idc_id:
            req = self.db.service_get_by_idc(zone.idc_id)
            agent.authenticate_by_zone_proxy(req, userid, zone.id)
            return self.cache_db.user_update(userid, zone.id)

        try:
            self._authenticate_cache(user, zone)
        except (exception.AuthorizationFailure, exception.Unauthorized) as e:
            raise exc.HTTPNotFound(explanation=e)

    @local_req
    def logout(self, req, userid):
        if userid:
            self.cache_db.user_clear(userid)
        return webob.Response(status_int=202)

    @local_req
    def project_absolute_limits(self, req, userid, id):
        user_project = self.db.user_project_get_by_id(userid, id)
        if not user_project:
            msg = _("Zone not availiable.")
            raise exc.HTTPNotFound(explanation=msg)
        limits = self.db.project_absolute_limits(user_project.project_id)
        return {'limits': limits}

    @local_req
    def user_absolute_limits(self, req, userid):
        user = self.db.user_get(userid)
        max_instances = user.get('default_instances', CONF.instance_count)
        total_instances = self.db.user_absolute_limits(userid)[0]
        limits = {"maxTotalInstances": max_instances,
                  "totalInstancesUsed": total_instances}
        return {'limits': limits}

    @local_req
    def availability_zone_list(self, req):
        zones = []
        user_id = req.GET.get('user_id')
        zone_list = self.db.zone_get_all()
        if not user_id:
            for zone in zone_list:
                #if not zone['disabled']:
                    zones.append(zone)
        else:
            zone_dict = dict((z['id'], z) for z in zone_list)
            for zid in self.cache_db.user_get(user_id):
                zone = zone_dict.get(zid)
                if zone and not zone['disabled']:
                    zones.append(zone)
        return {"avail_zones": zones}

    @local_req
    def availability_zone_get(self, req, id):
        return {"avail_zone": self.db.zone_get(id)}

    @local_req
    def flavor_list(self, req, zid): #cg
        flavors = self.db.flavor_get_all(zid)
        return {"flavors": flavors}

    @local_req
    def image_list_detailed(self, req, zid): #cg
        images = self.db.image_get_all(zid)
        return {"images": images}

    @local_req
    def server_list(self, req, userid):
        return {"servers": self._get_servers(userid)}

    @local_req
    def server_detail(self, req, userid):
        servers = []
        user = self.db.user_info_get(userid, 'admin')
        if not user:
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)

        return {"servers": self._get_servers()}

    def _get_servers(self, user_id=None):
        servers = []
        zones = [zone['id'] for zone in self.db.zone_get_all()
                 if zone['disabled']]
        for server in self.db.server_get_all(user_id=user_id):
            if server['availability_zone'] in zones:
                server['status'] = None
            server['status'] = common.status_from_state(server['status'])
            servers.append(server)
        return servers

    @local_req
    def server_get(self, req, id):
        server = self.db.server_get(id)
        if not server:
            msg = _("Instance could not be found")
            raise exc.HTTPNotFound(explanation=msg)
        else:
            server['status'] = common.status_from_state(server['status'])

        return {'server': server}

    @local_req
    def server_delete(self, req, id, userid):
        self._server_delete(req, id, userid)

    def server_delete_proxy(self, req, id, userid):
        self._server_delete(req, id, userid, check=False)

    def _server_delete(self, req, id, userid, check=True):
        server = self.db.server_get(id)
        if not server:
            msg = _("Instance could not be found")
            raise exc.HTTPNotFound(explanation=msg)

        # proxy -> server_delete_proxy
        if check:
            zone = self.db.zone_get(server.availability_zone)
            if zone and zone.idc_id != CONF.idc_id:
                req = self.db.service_get_by_idc(zone.idc_id)
                return agent.server_delete_proxy(req, userid, id)

        try:
            if server.user_id == userid:
                project_id = server.project_id
            else:
                user_project = self.db.user_project_get_by_id(userid, server.availability_zone)
                if not user_project:
                    msg = _("Project not found")
                    raise exc.HTTPNotFound(explanation=msg)

                project_id = user_project.project_id

            agent.server_delete(self.request_get(project_id), id)
        except exception.novaclient.NotFound as e:
            LOG.error(e)
        except Exception as e:
            LOG.error(e)

        self.notify_about_instance(id, 'delete')
        self.notify_about_disk(id, 'delete')
        self.db.server_delete(id)

    def available_gateway(self, hostname):
        gateway = self.db.gateway_get_by_name(hostname)

        avail_hostname = [g.hostname for g in self.db.gateway_get_by_idc(
                          gateway['idc_id'])]

        if avail_hostname and hostname not in avail_hostname:
            return avail_hostname[0]

        return hostname

    def _server_update_thread(self, req, id, pid, image, flavor, gateway_name=None, device_map=None):
        try_count = 500
        while try_count > 0:
            try_count = try_count - 1
            server = agent.server_get(self.request_get(pid), id)
            if server and server.status.lower() in (vm_states.ACTIVE, vm_states.ERROR):
                serv = self._format_server(server)
                if server.status.lower() == vm_states.ACTIVE:
                    image_obj = self.db.image_get(image)
                    if gateway_name is None:
                        gateway_name = self.available_gateway(serv['host'])
                    firewall = {'instance_id': id, 'hostname': gateway_name}
                    for port in image_obj.get('property', []):
                        gateway = self.db.gateway_count(gateway_name)
                        firewall['gateway_port'] = gateway.count
                        firewall['service_port'] = port
                        self._firewall_create(req, firewall)
                    self.notify_about_instance(id, 'create', flavor=flavor)
                    if device_map:
                        self.notify_about_disk(id, 'create', device_map=device_map)
                self.db.server_update(id, serv)
                break
            else:
                greenthread.sleep(2)

    @local_req
    def server_action(self, req, id, body):
        self._server_action(req, id, body)

    def server_action_proxy(self, req, id, body):
        self._server_action(req, id, body, check=False)

    def _server_action(self, req, id, body, check=True):
        action = self._from_body(body, 'action')
        server = self.db.server_get(id)

        # proxy -> server_action_proxy
        if check:
            zone = self.db.zone_get(server.availability_zone)
            if zone.idc_id != CONF.idc_id:
                method = 'server_%s_proxy' % action
                if hasattr(agent, method):
                    req = self.db.service_get_by_idc(zone.idc_id)
                    return getattr(agent, method)(req, id, action=action)
                else:
                    msg = "type object '%s' has no attribute '%s'" % (agent, method)
                    raise AttributeError(msg)

        status = {'updated_at': timeutils.utcnow()}

        if not timeutils.is_older_than(
                server['updated_at'], CONF.instance_interval):
            msg = _("Your operation is too frequent. Please try again later.")
            raise exc.HTTPLocked(explanation=msg)

        if action == 'start':
            func = agent.server_start
            status['status'] = vm_states.ACTIVE
            status['power_state'] = power_state.RUNNING
        elif action == 'stop':
            func = agent.server_stop
            status['status'] = vm_states.STOPPED
            status['power_state'] = power_state.SHUTDOWN
        else:
            msg = _('Action "%s" do not supported') % action
            raise HTTPBadRequest(explanation=msg)

        try:
            func(self.request_get(server['project_id']), id)
        except exception.Conflict as e:
            LOG.error(e)

        self.db.server_update(id, status)
        self.notify_about_instance(id, action, server=server)

    def simple_scheduler(self, user_id, avail_zones, **kwargs):
        while len(avail_zones) > 0:
            avail_zone = min(avail_zones.iteritems(), key=lambda d:d[1][0])
            zone_id = avail_zone[0]
            image_id = avail_zone[1][1]
            avail_zones[zone_id][0] += 1

            user_project = self.db.user_project_get_by_id(user_id, zone_id)
            if not user_project:
                #msg = _("User not found.")
                #raise exc.HTTPNotFound(explanation=msg)
                avail_zones.pop(zone_id)
                continue

            project_id = user_project.project_id

            limit = self.db.project_absolute_limits(project_id)

            if (limit["maxTotalInstances"] - limit["totalInstancesUsed"]
                                           - kwargs['instance_count'] < 0):
                #msg = _("Quota exceeded.")
                #raise exc.HTTPBadRequest(explanation=msg)
                avail_zones.pop(zone_id)
                continue

            return (zone_id, project_id, image_id)

    @local_req
    def server_create(self, req, userid, body):
        all_server = []
        server = self._from_body(body, 'server')
        kwargs = self._from_body(body, 'kwargs')

        try:
            net_type = int(kwargs.pop('net_type', 1))
            #self.network_types[userid] = net_type
        except KeyError:
            msg = _("You must select a network type.")
            raise exc.HTTPBadRequest(explanation=msg)

        count = int(kwargs['instance_count'])
        image_id = server.pop('image', None)
        device_mapping_v2 = kwargs.get('block_device_mapping_v2')

        if image_id is None and device_mapping_v2:
            for device in device_mapping_v2:
                if device['source_type'] == 'image':
                    image_id = device['uuid']
                    break

        if image_id is None:
            msg = _("You must select an image.")
            raise exc.HTTPBadRequest(explanation=msg)

        gateway_name = kwargs.pop('gateway', None)

        if gateway_name and not self.db.gateway_get_by_name(gateway_name):
            msg = _("Gateway name %s could not be found") % gateway_name
            raise exc.HTTPNotFound(msg)

        msg = _("Availiable zone not found")
        zone_id = kwargs.pop('zone_id', None)

        if zone_id is None:
            avail_zones= self.db.zone_get_by_image(image_id, self.cache_db.user_get(userid))
            if not avail_zones:
                raise exc.HTTPNotFound(msg)
        else:
            if not self.db.zone_get(zone_id) or zone_id not in self.cache_db.user_get(userid):
                raise exc.HTTPNotFound(explanation=msg)
            avail_zones= self.db.zone_get_by_image(image_id, [zone_id])

        for i in range(count):
            #if count > 1:
            kwargs.pop('accessIPv4', None)

            kwargs['instance_count'] = 1

            resource = self.simple_scheduler(userid, avail_zones, **kwargs)
            LOG.info("Available zones [%s] selected zone [%s]", avail_zones, resource)

            if not resource:
                msg = _("Quota exceeded.")
                raise exc.HTTPBadRequest(explanation=msg)

            zone_id, project_id, image_id = resource

            try:
                network = self.db.network_get(net_id=net_type, zone_id=zone_id)
                #if not kwargs.get('accessIPv4', None):
                while True:
                    ip_address = self.db.generate_ip(userid, net_type)
                    if not ip_address:
                        msg = _("All IPs allocated")
                        raise exc.HTTPConflict(explanation=msg)

                    if not self.db.network_get_by_project(userid, ip_address):
                        #kwargs['accessIPv4'] = ip_address
                        break
                #else:
                #    _server = self.db.network_get_by_project(userid, kwargs['accessIPv4'])
                #    if _server:
                #        msg = _("This address is be in used")
                #        raise exc.HTTPConflict(explanation=msg)
                kwargs['nics'] = [{'net-id': network.id, 'v4-fixed-ip': ip_address}]
            except exception.NetworkTypeNotFound as e:
                raise exc.HTTPNotFound(explanation=e.args[0])

            if count > 1:
                name = '%s-%s' % (server['name'], ip_address.replace('.', '-'))
            else:
                name = server['name']

            zone = self.db.zone_get(zone_id)
            if zone.idc_id != CONF.idc_id:
                req = self.db.service_get_by_idc(zone.idc_id)
                base = {'name': name,
                        'project_id': project_id,
                        'image_id': image_id,
                        'zone_id': zone_id,
                        'gateway_name': gateway_name}

                _server = agent.server_create_proxy(
                        req, userid, base, server, kwargs).to_dict()
            else:
                serv = agent.server_create(self.request_get(project_id),
                        server['name'], image_id, server['flavor'], **kwargs)
                        #server['name'], server['image'], server['flavor'], **kwargs)

                _server = {'id': serv.id,
                           'name': name,
                           'availability_zone': zone_id,
                           'project_id': project_id,
                           'user_id': userid,
                           'address': ip_address,
                           'image': image_id,
                           'flavor': server['flavor'],
                           'status': vm_states.BUILDING,
                           'updated_at': timeutils.utcnow(),
                }
                self.db.server_create(_server)

                self.add_thread(self._server_update_thread,
                                req, serv.id,
                                project_id,
                                image_id,
                                server['flavor'],
                                gateway_name,
                                device_mapping_v2)

            all_server.append(_server)

        return {'server': {'servers': all_server}}

    def server_create_proxy(self, req, userid, body):
        base = self._from_body(body, 'base')
        server = self._from_body(body, 'server')
        kwargs = self._from_body(body, 'kwargs')

        serv = agent.server_create(self.request_get(base['project_id']),
                server['name'], base['image_id'], server['flavor'], **kwargs)

        _server = {'id': serv.id,
                   'name': base['name'],
                   'availability_zone': base['zone_id'],
                   'project_id': base['project_id'],
                   'user_id': userid,
                   'address': kwargs['nics'][0]['v4-fixed-ip'],
                   'image': base['image_id'],
                   'flavor': server['flavor'],
                   'status': vm_states.BUILDING,
                   'updated_at': timeutils.utcnow(),
        }
        self.db.server_create(_server)

        self.add_thread(self._server_update_thread,
                        req, serv.id,
                        base['project_id'],
                        base['image_id'],
                        server['flavor'],
                        base['gateway_name'],
                        kwargs.get('block_device_mapping_v2'))

        return {'server': _server}

    @local_req
    def _server_create(self, req, userid, zone_id, body): #cg
        all_server = []
        server = self._from_body(body, 'server')
        kwargs = self._from_body(body, 'kwargs')

        user_project = self.db.user_project_get_by_id(userid, zone_id)
        if not user_project:
            msg = _("User not found.")
            raise exc.HTTPNotFound(explanation=msg)

        project_id = user_project.project_id

        limit = self.db.project_absolute_limits(project_id)

        if (limit["maxTotalInstances"] - limit["totalInstancesUsed"]
                                       - kwargs['instance_count'] < 0):
            msg = _("Quota exceeded.")
            raise exc.HTTPBadRequest(explanation=msg)

        if not self.db.zone_get(zone_id):
            msg = _("Zone could not be found.")
            raise exc.HTTPNotFound(explanation=msg)

        count = kwargs['instance_count']
        image_id = server['image']
        device_mapping_v2 = kwargs.get("block_device_mapping_v2")

        if image_id is None and device_mapping_v2:
            for device in device_mapping_v2:
                if device["source_type"] == "image":
                    image_id = device["uuid"]
                    break

        if image_id is None:
            msg = _("You must select an image.")
            raise exc.HTTPBadRequest(explanation=msg)

        for i in range(count):
            kwargs['instance_count'] = 1
            try:
                net_type = int(kwargs.pop('net_type', 1))
                self.network_types[userid] = net_type
            except KeyError:
                msg = _("You must select a network type.")
                raise exc.HTTPBadRequest(explanation=msg)
            if not kwargs.get('accessIPv4', None):
                while True:
                    ip_address = self.db.generate_ip(userid, net_type)
                    if not ip_address:
                        msg = _("All IPs allocated")
                        raise exc.HTTPConflict(explanation=msg)
                    if not self.db.network_get_by_project(userid, ip_address):
                        kwargs['accessIPv4'] = ip_address
                        break
            else:
                _server = self.db.network_get_by_project(userid, kwargs['accessIPv4'])
                if _server:
                    msg = _("This address is be in used")
                    raise exc.HTTPConflict(explanation=msg)

            name = '%s%s' % (server['name'], kwargs['accessIPv4'].replace('.', '-'))

            serv = agent.server_create(self.request_get(project_id),
                server['name'], server['image'], server['flavor'], **kwargs)

            self.add_thread(self._server_update_thread, req, serv.id, project_id, image_id,
                            server['flavor'], device_mapping_v2)
            _server = {'id': serv.id,
                       'name': (name if count > 1 else server['name']),
                       'availability_zone': zone_id,
                       'project_id': project_id,
                       'user_id': userid,
                       'address': kwargs['accessIPv4'],
                       'image': image_id,
                       'flavor': server['flavor'],
                       'status': vm_states.BUILDING,
                       'updated_at': timeutils.utcnow(),
            }
            all_server.append(_server)
            self.db.server_create(_server)

        return {'server': {'servers': all_server}}

    def _format_server(self, serv, **kwargs):
        server = {}
        server["id"] = serv.id
        if serv.addresses.values():
            net = serv.addresses.values()[0][0]
            address = net['addr']
            mac_address = net.get('OS-EXT-IPS-MAC:mac_addr')
        else:
            address = None
            mac_address = None
        server["address"] = address
        server["mac_address"] = mac_address
        server["project_id"] = serv.tenant_id
        # server["phy_ipv4"] = getattr(serv, 'phy_ipv4') # Deprecated
        try:
            server["host"] = getattr(serv, 'OS-EXT-SRV-ATTR:host')
        except:
            server["host"] = serv.host
        server["fake_hostname"] = server["host"]
        server["status"] = serv.status.lower()
        server["power_state"] = getattr(serv, 'OS-EXT-STS:power_state')
        server["created_at"] = timeutils.strtime(timeutils.parse_isotime(serv.created))
        server.update(kwargs)

        return server

    @local_req
    def server_network(self, req, id, body):
        network = self._from_body(body, 'network')
        address = self._from_body(network, 'address')
        server = self.db.network_get_by_project(id, address)
        if server:
            msg = _("This address is be in used")
            raise exc.HTTPConflict(explanation=msg)

    @local_req
    def firewall_get(self, req, id):
        firewall = self.db.firewall_get_by_instance(id)
        return {'firewall': [dict(fw.iteritems()) for fw in firewall]}

    @local_req
    def firewall_delete(self, req, fid):
        #firewall = self.db.firewall_get(id=fid)
        #if not firewall:
        #    msg = _('The firewall could not be found.')
        #    raise exc.HTTPNotFound(explanation=msg)

        #instance_id, firewall_id = fid.split('_')
        #server = self.db.server_get(instance_id)
        #firewall_zone = self.db.gateway_get_by_name(firewall['hostname'])
        ##if not firewall['fake_zone']:
        ##    zone = self._gateways[firewall['hostname']]['zone']
        ##    data = {'action': 'delete', 'server': server, 'firewall': firewall}
        ##    o = urlparse.urlparse(self.zones[zone]['auth_url'])
        ##    self.client.set_management_url(self._build_url(
        ##            o.netloc.split(':')[0], CONF.agent_port))
        ##    self.client.put('/firewall', body=data)

        #user_project = self.db.user_project_get_by_id(
        #    server['user_id'], firewall_zone['zone'])

        #if not user_project:
        #    msg = _('The firewall rule could not be deleted.')
        #    raise exc.HTTPNotFound(explanation=msg)

        #agent.firewall_delete(self.request_get(instance_id=instance_id), firewall_id)

        #if not firewall['fake_zone']:
        #    agent.firewall_update(self.request_get(user_project.project_id), instance_id,
        #                          action='delete', firewall=firewall,
        #                          server=self._format_firewall(server))

        #instance_id, firewall_id = fid.split('_')
        self.db.firewall_delete(int(fid))
        return webob.Response(status_int=202)

    @local_req
    def firewall_exist(self, req, id, body):
        firewall = self._from_body(body, 'firewall')
        firewall_ref = self.db.firewall_get(hostname=firewall['hostname'],
                                            gateway_port=firewall['gateway_port'])
        return {'firewall': firewall_ref}

    @local_req
    def firewall_create(self, req, body):
        firewall = self._from_body(body, 'firewall')
        return self._firewall_create(req, firewall)

    def _firewall_create(self, req, firewall):
        server = self.db.server_get(firewall['instance_id'])
        firewall_zone = self.db.gateway_get_by_name(firewall['hostname'])
        firewall['fake_zone'] =  (server['availability_zone'] == firewall_zone['zone'])
        ##if not firewall['fake_zone']:
        ##    data = {'action': 'create', 'server': server, 'firewall': firewall}
        ##    o = urlparse.urlparse(self.zones[firewall_zone]['auth_url'])
        ##    self.client.set_management_url(self._build_url(
        ##            o.netloc.split(':')[0], CONF.agent_port))
        ##    self.client.put('/firewall', body=data)

        #user_project = self.db.user_project_get_by_id(
        #    server['user_id'], firewall_zone['zone'])

        #if not user_project:
        #    msg = _('The firewall rule could not be created.')
        #    raise exc.HTTPNotFound(explanation=msg)

        #nfirewall = agent.firewall_create(
        #    self.request_get(server['project_id']), **firewall)._info

        #if not firewall['fake_zone']:
        #    agent.firewall_update(self.request_get(user_project.project_id), server['id'],
        #                          action='create', firewall=nfirewall,
        #                          server=self._format_firewall(server))

        #nfirewall['id'] = '%s_%s' % (server['id'], nfirewall['id'])

        #self.db.firewall_create(nfirewall)
        #return {'firewall': nfirewall}

        self.db.firewall_create(firewall)
        return {'firewall': firewall}

    #def _format_firewall(self, server):
    #    _server = {}
    #    _server['uuid'] = server['id']
    #    _server['log_ipv4'] = server['address']
    #    _server['phy_ipv4'] = server['phy_ipv4']
    #    _server['mac_address'] = server['mac_address']
    #    return _server

    @local_req
    def security_group_list(self, req, id):
        security_groups = collections.defaultdict(set)
        groups = self.db.security_group_get_by_user(id)
        for group in groups:
            security_groups[group.top].add(group.bottom)
            security_groups[group.bottom].add(group.top)
        return {'security_groups': security_groups}

    @local_req
    def security_group_update(self, req, id, body): #cg
        security_group = self._from_body(body, 'security_group')

        #top = self.db.server_get(security_group['top'])
        #bottom = self.db.server_get(security_group['bottom'])

        #def _wrapper(src, dst):
        #    src['uuid'] = src['id']
        #    dst['uuid'] = dst['id']
        #    data = {"kwargs": {'src': json.to_primitive(src), 'dst': json.to_primitive(dst)}}
        #    zone = self.db.zone_get(src['availability_zone'])
        #    url = utils.replace_url(zone['auth_url'], port=CONF.agent_port, path='')
        #    self.client.set_management_url(url)
        #    self.client.put('/group/delete', body=data)

        #if top["availability_zone"] == bottom["availability_zone"]:
        #    agent.security_group_update(self.request_get(top["project_id"]),
        #        top["availability_zone"], **security_group)

        if security_group['action'] == 'create':
            self.db.security_group_create(
                id, security_group['top'], security_group['bottom'])
        elif security_group['action'] == 'delete':
            self.client.set_management_url(CONF.controller_url)
            self.client.put('/v1.0/group', body={'sid': security_group['top'],
                                                 'did': security_group['bottom']})
            self.db.security_group_delete(
                id, security_group['top'], security_group['bottom'])

    @local_req
    def gateway_list(self, req):
        gateways = self.db.gateway_get_all()
        return {'gateways': gateways}

    def gateway_get_by_id(self, req, id):
        gateway = self.db.gateway_get(id)
        return {'gateway': gateway}

    def gateway_get(self, req, body):
        hostname = self._from_body(body, "hostname")
        gateway = self.db.gateway_get_by_name(hostname)
        return {'gateway': gateway}

    def device_get(self, req, id):
        gateway = self.db.gateway_get(id)
        if not gateway or not gateway.int_ip:
            msg = _("Host '%s' not found" % gateway.hostname)
            raise exc.HTTPBadRequest(explanation=msg)

        data = {'hostname': gateway.hostname}
        url = utils.replace_url('http://', host=gateway.int_ip, port=CONF.agent_port)
        self.client.set_management_url(url)
        resp, body = self.client.post('/devices', body=data)

        return {'device': body}

    @local_req
    def gateway_get_by_instance(self, req, id):
        server = self.db.server_get(id)
        gateway = self.db.gateway_get_by_name(server['host'])
        if not gateway:
            gateways = []
        else:
            gateways = self.db.gateway_get_by_idc(gateway['idc_id'])
            if not gateways:
                gateways = [gateway]
        #gateways = self.db.gateway_get_all(server['availability_zone'])
        return {'gateways': gateways}

    @local_req
    def gateway_update(self, req, id, body):
        gateway = self._from_body(body, 'gateway')
        try:
            self.db.gateway_update(id, **gateway)
            return webob.Response(status=202)
        except:
            return webob.Response(status=404)

    def _gateway_update(self, req, id, body):
        gateway = self._from_body(body, 'gateway')
        #server = self.cache_db.server_get(id)
        #old_gateway = self._gateways[old_hostname]
        #new_gateway = self._gateways[new_hostname]
        old_hostname = gateway['old_gateway']
        new_hostname = gateway['new_gateway']
        old_gateway = self.db.gateway_get_by_name(old_hostname)
        new_gateway = self.db.gateway_get_by_name(new_hostname)

        if old_gateway['idc_id'] != new_gateway['idc_id']:
            msg = _("Don't match the host (%s)." % new_hostname)
            raise exc.HTTPBadRequest(explanation=msg)

        if old_hostname != new_hostname:
            #if old_gateway['idc_id'] == new_gateway['idc_id']:
            #    address = new_gateway['int_ip']
            #else:
            #    address = new_gateway['ext_ip']
            #    #msg = _("Don't match the host (%s)." % new_hostname)
            #    #raise exc.HTTPBadRequest(explanation=msg)
            _gateway = {'fake_hostname': new_hostname,
                        'fake_zone': old_gateway['zone']==new_gateway['zone']}
            agent.gateway_update(self.request_get(instance_id=id),
                                 id, old_hostname, _gateway)
            hostname = {'fake_hostname': new_hostname}
            self.db.server_update(id, hostname)

        return webob.Response(status=202)

    def _format_user(self, user):
        return {'id': user.uuid,
                'username': user.username,
                'email': user.email,
                'phone': user.phone,
                'company': user.company,
                'created_at': user.created_at,
                'updated_at': user.updated_at,
        }

    @local_req
    def user_list(self, req, id):
        if not self.db.user_info_get(id, 'admin'):
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)

        users = [self._format_user(user) for user in self.db.user_get_all()]

        return {'users': users}

    @local_req
    def user_get(self, req, id):
        user = self._format_user(self.db.user_get(id))
        return {'user': user}

    def _register_thread(self, request, auth, check=True):
        # proxy -> register_proxy
        if check and request.idc_id != CONF.idc_id:
            req = self.db.service_get_by_idc(request.idc_id)
            return agent.register_proxy(req, json.to_primitive(request),
                                        json.to_primitive(auth))

        request['auth_url'] = utils.replace_url(
            request['auth_url'], port=CONF.admin_port)

        def _register_try(func, **kwargs):
            try_count = 1
            while try_count > 0:
                try_count -= 1
                try:
                    return func(request, **kwargs)
                except Exception as e:
                    auth['message']= e.message
                    #greenthread.sleep(2)

            if try_count <= 0:
                # Store database on error
                auth['method'] = func.__name__
                auth['auth_url'] = request['auth_url']
                self.db.user_task('register', json.dumps(json.to_primitive(auth)))
                raise Exception('User "%s" on "%s" register failed.' % (
                    auth['username'], request['auth_url']))

        tenant_obj = _register_try(agent.tenant_create, name=auth['username'],
                description='%s tenant' % auth['username'], enabled=True)
        user_obj = _register_try(agent.user_create, name=auth['username'], email=auth['email'],
                password=auth['password'], project=tenant_obj.id, enabled=True)

        self.db.user_project_create(auth.uuid, tenant_obj.id, user_obj.id,
                                    request.id, request.default_instances)

        LOG.debug('User "%s" on "%s" register successful' % (
            auth['username'], request['auth_url']))

    def _send_mail(self, auth):
        try_count = 1
        while try_count > 0:
            try_count -= 1
            try:
                return api_utils.register_sendmail(auth)
            except Exception as e:
                auth['message'] = e.message
                #greenthread.sleep(2)

        if try_count <= 0:
            self.db.user_task('sendmail', json.dumps(auth))
            raise Exception('User "%s" send email failed.' % args[0])

    def register_proxy(self, req, body):
        zone = self._from_body(body, 'zone')
        auth = self._from_body(body, 'auth')
        self._register_thread(zone, auth, check=False)
        return {'auth': auth}

    @local_req
    def register(self, req, body):
        auth = self._from_body(body, 'auth')

        if auth['username'] in utils.user_filters or \
                self.db.checkdata('username', auth['username']):
            msg = _('The username "%s" is already in used.' % auth['username'])
            raise exc.HTTPConflict(explanation=msg)

        if not auth.get('password', None):
            auth['password'] = api_utils.create_password()

        user = self.db.register(username=auth['username'],
                                password=auth['password'],
                                email=auth['email'],
                                type=auth['type'],
                                phone=auth['phone'],
                                company=auth['company'],
                                reason=auth['reason'])
        self.add_thread(self._send_mail, auth)
        LOG.debug('User %s[%s] send successfully!' % (auth['username'], auth['email']))

        for zone in self.db.zone_get_all():
            self.add_thread(self._register_thread, zone, user)

        try:
            from bill import api as bill_api
            bill_api.register_project(user.uuid)
        except Exception as e:
            LOG.error(e)

        return {'auth': {'id': user['uuid'], 'username': user['username']}}

    @local_req
    def checkdata(self, req, body):
        data = self._from_body(body, 'check')
        for key, val in data.items():
            if (key == 'username' and val in utils.user_filters) or \
                    self.db.checkdata(key, val):
                msg = _('The %s "%s" is already in used.' % (key, val))
                raise exc.HTTPConflict(explanation=msg)

    @local_req
    def validate_user(self, req, body):
        user = self._from_body(body, 'user')
        if not self.db.validate_user(user):
            msg = _('The user "%s" does not match.' % user.get('username'))
            raise exc.HTTPNotFound(explanation=msg)

    @local_req
    def update_user_key(self, req, body):
        user = self._from_body(body, 'user')

        if not user['kwargs'].get('key', None):
            user['kwargs']['key'] = utils.gen_uuid()

        user_obj = self.db.update_user(
                user['base'], extra={'key': user['kwargs']['key']})

        qparams = {'uid': user_obj.uuid,
                   'username': user['base']['username'],
                   'email': user['base']['email'],
                   'tid': user['kwargs']['key']}

        url = "%s?%s" % (user['kwargs']['url'],
                         parse.urlencode(qparams))

        data = {'email': user['base']['email'],
                'subject': '[Daolicloud] Reset your password!',
                'body': 'Please Click URL: <br /><a href="%s" title="Click">%s</a>' % (
                url, url)}

        utils.send_mail([data])
        return webob.Response(status=202)

    @local_req
    def getpassword(self, req, body):
        user = self._from_body(body, 'user')
        self._getpassword(user['base'], user['kwargs']['key'])
        return webob.Response(status=202)

    def _getpassword(self, user, key):
        user_obj = self.db.validate_user(user)

        if not user_obj:
            msg = _("User not found.")
            raise exc.HTTPNotFound(explanation=msg)

        if not user_obj['extra'] or key != user_obj['extra']['key']:
            msg = _("Request expired.")
            raise exc.HTTPForbidden(msg)

    @local_req
    def resetpassword(self, req, body):
        user = self._from_body(body, 'user')
        self._getpassword(user['base'], user['kwargs']['key'])
        password = user['kwargs']['password']

        user_obj = self.db.update_user(
                user['base'], password=password, extra={})

        user_projects = self.db.user_project_get_by_user(user_obj.uuid)

        zone_dict = dict((zone['id'], zone) for zone in self.db.zone_get_all())

        for up in user_projects:
            zone = zone_dict.get(up.zone_id)
            if zone:
                # proxy -> resetpassword_proxy
                if zone.idc_id != CONF.idc_id:
                    req = self.db.service_get_by_idc(zone.idc_id)
                    return agent.resetpassword_proxy(req, keystone_user_id, password)
                try:
                    agent.user_update_password(zone, up.keystone_user_id, password)
                except Exception as e:
                    data = {'auth': zone,
                            'password': password,
                            'message': e.message,
                            'keystone_user_id': up.keystone_user_id}
                    self.db.user_task('resetpassword', json.dumps(data))

        return webob.Response(status=202)

    def resetpassword_proxy(self, req, body):
        zone = self._from_body(body, 'zone')
        auth = self._from_body(body, 'auth')
        try:
            agent.user_update_password(zone, auth['keystone_user_id'], auth['password'])
        except Exception as e:
            data = {'auth': zone, 'password': password, 'message': e.message,
                    'keystone_user_id': auth['keystone_user_id']}

            self.db.user_task('resetpassword', json.dumps(data))

        return webob.Response(status=202)

    @local_req
    def user_delete(self, req, id, userid):
        if not self.db.user_info_get(id, 'admin'):
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)

        user_projects = self.db.user_project_get_by_user(userid)
        zone_dict = dict((zone.id, zone) for zone in self.db.zone_get_all())

        for user_project in user_projects:
            #if not zone_dict.has_key(user_project.zone_id):
            #    continue

            zone = zone_dict[user_project.zone_id]
            zone['auth_url'] = utils.replace_url(zone['auth_url'],
                                                 port=CONF.admin_port)

            agent.tenant_delete(zone, user_project.project_id)
            agent.user_delete(zone, user_project.keystone_user_id)

        self.db.user_delete(userid)
        self.cache_db.user_clear(userid)

        return webob.Response(status=202)

    @local_req
    def monitor(self, req, id):
        server = self.db.server_get(id)
        if not server:
            msg = 'Instance (%s) could not be found.'
            raise exception.InstanceNotFound(msg % id)
        gateway = self.db.gateway_get_by_name(server['host'])
        if not gateway:
            msg = 'Gateway (%s) could not be found.'
            raise exception.InstanceNotFound(msg % server['host'])
        monitor_path = 'containers/docker/nova-%s' % id
        monitor_url = self._build_url(gateway['ext_ip'], 8088, monitor_path)
        return {'monitor': {'monitor_url': monitor_url}}

    @local_req
    def user_login_list(self, req, id):
        if not self.db.user_info_get(id, 'admin'):
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)
        user = self.db.user_login_list()
        return {'user': [dict(u) for u in user]}

    @local_req
    def user_login_detail(self, req, id):
        user = self.db.user_login_list(user_id=id)
        return {'user': [dict(u) for u in user]}

    def _format_image(self, image):
        _image = {}
        _image['id'] = image.id
        _image['name'] = image.name
        _image['checksum'] = image.checksum
        _image['container_format'] = image.container_format
        _image['disk_format'] = getattr(image, 'disk_format', 'raw')
        _image['is_public'] = image.is_public
        _image['min_disk'] = image.min_disk
        _image['min_ram'] = image.min_disk
        _image['size'] = image.size
        _image['owner'] = image.owner
        _image['status'] = image.status
        _image['property'] = [22]
        if _image['container_format'] == 'docker':
            try:
                display_format = image.name.split('-')[1].replace('.', '')
            except IndexError:
                display_format = None
            if display_format == 'wordpress':
                _image['property'].append(80)
            _image['display_format'] = display_format
        else:
            _image['display_format'] = 'vm'
        return _image

    @local_req
    def image_list(self, req):
        return {'images': self.db.image_get_all()}

    @local_req
    def image_get(self, req, id):
        return {'images': self.db.image_get_all(id)}

    @local_req
    def image_create(self, req, zone, body):
        _image = self._from_body(body, 'image')
        image = self.db.image_create(zone, _image)
        return {'image': image}

    @local_req
    def image_delete(self, req, id):
        self.db.image_delete(id)

    @local_req
    def image_rebuild(self, req, body):
        self._image_rebuild(req, body)

    def image_rebuild_proxy(self, req, body):
        return self._image_rebuild(req, body, check=False)

    def _image_rebuild(self, req, body, check=True):
        zone_id = self._from_body(body, 'zone')

        if check:
            zone = self.db.zone_get(zone_id)
            if zone.idc_id != CONF.idc_id:
                req = self.db.service_get_by_idc(zone.idc_id)
                return agent.image_rebuild_proxy(req, body)

        user_id = self._from_body(body, 'user_id')

        self.db.image_delete(zone=zone_id)

        user_project = self.db.user_project_get_by_id(user_id, zone_id)
        images, has_more = agent.image_list_detailed(
                self.request_get(user_project.project_id))

        for image in images:
            self.db.image_create(zone_id, self._format_image(image))

        return webob.Response(status=202)

    @local_req
    def zone_create(self, req, body):
        return self._zone_create(req, body)

    def zone_create_proxy(self, req, body):
        return self._zone_create(req, body, check=False)

    def _zone_create(self, req, body, check=True):
        zone = self._from_body(body, 'zone')
        user_id = self._from_body(body, 'user_id')

        if not zone.has_key('idc_id'):
            zone['idc_id'] = CONF.idc_id

        user = self.db.user_info_get(user_id, 'admin')
        if not user:
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)

        if self.db.zone_exists(auth_url=zone['auth_url']):
            msg = _("Zone (%s) already exists") % zone['auth_url']
            raise exc.HTTPConflict(explanation=msg)

        if check and zone['idc_id'] != CONF.idc_id:
            service = self.db.service_get_by_idc(zone['idc_id'])
            if not service:
                msg = _("IDC not reigisted")
                raise exc.HTTPNotFound(explanation=msg)

            zone_obj = agent.zone_create_proxy(service, body)
            return self.cache_db.user_update(user_id, zone_obj.id)

        zone_ref = self.db.zone_create(zone)

        try:
            self._authenticate_cache(user, zone_ref)
        except Exception as e:
            self.db.zone_delete(zone_ref.id)
            raise

        self.add_thread(self._sync_user_thread, zone_ref)

        return {'zone': zone_ref}

    @local_req
    def zone_delete(self, req, id):
        self.db.zone_delete(id)
        self.db.image_delete(zone=id)
        self.db.flavor_delete(zone=id)
        self.db.gateway_delete(zone=id)
        self.db.network_delete(zone=id)
        self.db.user_project_delete(id)
        return webob.Response(status_int=202)

    def _format_service(self):
        _service = {}
        _service['name'] = CONF.host
        _service['url'] = 'http://%s:%s' % (os.environ.get('host',
                CONF.my_ip), CONF.daoliproxy_listen_port)
        _service['topic'] = CONF.topic
        _service['idc_id'] = CONF.idc_id
        return _service

    def service_create(self, req, body):
        if body and body.get('gateway'):
            gateway = body['gateway']
        else:
            gateway = Network().gateway_get()

        if not gateway.has_key('idc_id'):
            gateway['idc_id'] = CONF.idc_id

        service = self.db.service_create(self._format_service())

        gateway['zone'] = service.id

        host = os.environ.get('host')
        if host:
            gateway['vext_ip'] = host

        if not self.db.gateway_get_by_name(CONF.host):
            gateway['hostname'] = CONF.host
            self.db.gateway_create(service.id, gateway)
        else:
            self.db.gateway_update(CONF.host, **gateway)

        return {'service': service}

    def _format_flavor(self, flavor):
        _flavor = {}
        _flavor['flavorid'] = flavor.id
        _flavor['name'] = flavor.name
        _flavor['vcpus'] = flavor.vcpus
        _flavor['ram'] = flavor.ram
        _flavor['disk'] = flavor.disk
        _flavor['swap'] = flavor.swap
        _flavor['ephemeral'] = getattr(flavor,
            'OS-FLV-EXT-DATA:ephemeral', 0)
        _flavor['rxtx_factor'] = flavor.rxtx_factor
        _flavor['is_public'] = getattr(flavor,
            'os-flavor-access:is_public', True)
        return _flavor

    @local_req
    def flavor_get_by_zone(self, req, id):
        return {'flavors': self.db.flavor_get_all(id)}

    @local_req
    def flavor_create(self, req, zone, body):
        _flavor = self._from_body(body, 'flavor')
        flavor = self.db.flavor_create(zone, _flavor)
        return {'flavor': flavor}

    @local_req
    def flavor_delete(self, req, id):
        self.db.flavor_delete(id)

    @local_req
    def flavor_rebuild(self, req, body):
        self._flavor_rebuild(req, body)

    def flavor_rebuild_proxy(self, req, body):
        return self._flavor_rebuild(req, body, check=False)

    def _flavor_rebuild(self, req, body, check=True):
        zone_id = self._from_body(body, 'zone')

        if check:
            zone = self.db.zone_get(zone_id)
            if zone.idc_id != CONF.idc_id:
                req = self.db.service_get_by_idc(zone.idc_id)
                return agent.flavor_rebuild_proxy(req, body)

        user_id = self._from_body(body, 'user_id')

        self.db.flavor_delete(zone=zone_id)

        user_project = self.db.user_project_get_by_id(user_id, zone_id)
        flavors = agent.flavor_list(self.request_get(user_project.project_id))

        if len(flavors) > CONF.flavor_count:
            flavors = flavors[:CONF.flavor_count]

        for flavor in flavors:
            self.db.flavor_create(zone_id, self._format_flavor(flavor))

        return webob.Response(status=202)

    @local_req
    def network_type_list(self, req):
        return {'networks': self.db.network_type_get()}

    @local_req
    def network_type_delete(self, req, id):
        self.db.network_type_delete(id)

    def _format_network(self, network):
        _network = {}
        _network['id'] = network.id
        _network['gateway'] = network.gateway

        netype = self.db.network_type_update(network.cidr)

        _network['netype'] = netype.id
        return _network

    @local_req
    def network_list(self, req, zid):
        networks = self.db.network_get_all()
        return {"networks": networks}

    @local_req
    def network_get_by_zone(self, req, id):
        return {"networks": self.db.network_get_all(zone=id)}

    @local_req
    def network_rebuild(self, req, body):
        self._network_rebuild(req, body)

    def network_rebuild_proxy(self, req, body):
        return self._network_rebuild(req, body, check=False)

    def _network_rebuild(self, req, body, check=True):
        zone_id = self._from_body(body, 'zone')

        if check:
            zone = self.db.zone_get(zone_id)
            if zone.idc_id != CONF.idc_id:
                req = self.db.service_get_by_idc(zone.idc_id)
                return agent.network_rebuild_proxy(req, body)

        user_id = self._from_body(body, 'user_id')

        self.db.network_delete(zone=zone_id)

        user_project = self.db.user_project_get_by_id(user_id, zone_id)
        networks = agent.network_list(
                self.request_get(user_project.project_id))

        for network in networks:
            self.db.network_create(zone_id, self._format_network(network))

        return webob.Response(status=202)

    @local_req
    def network_delete(self, req, id):
        self.db.network_delete(id)

    def _format_gateway(self, gateway):
        _gateway = {}
        _gateway['datapath_id'] = gateway.datapath_id
        _gateway['hostname'] = gateway.hostname
        _gateway['idc_id'] = gateway.idc_id
        _gateway['idc_mac'] = gateway.idc_mac
        _gateway['vint_dev'] = gateway.vint_dev
        _gateway['vint_mac'] = gateway.vint_mac
        _gateway['vext_dev'] = gateway.vext_dev
        _gateway['ext_dev'] = gateway.ext_dev
        _gateway['ext_mac'] = gateway.ext_mac
        _gateway['ext_ip'] = gateway.ext_ip
        _gateway['int_dev'] = gateway.int_dev
        _gateway['int_mac'] = gateway.int_mac
        _gateway['int_ip'] = gateway.int_ip
        return _gateway

    @local_req
    def gateway_get_by_zone(self, req, id):
        return {'gateways': self.db.gateway_get_all(id)}

    @local_req
    def gateway_create(self, req, zone, body):
        _gateway = self._from_body(body, 'gateway')
        LOG.error(_gateway)
        gateway = self.db.gateway_create(zone, _gateway)
        return {'gateway': gateway}

    @local_req
    def gateway_delete(self, req, id):
        self.db.gateway_delete(id)

    @local_req
    def gateway_rebuild(self, req, body):
        self._gateway_rebuild(req, body)

    def gateway_rebuild_proxy(self, req, body):
        return self._gateway_rebuild(req, body, check=False)

    def _gateway_rebuild(self, req, body, check=True):
        zone_id = self._from_body(body, 'zone')
        zone = self.db.zone_get(zone_id)

        if check:
            if zone.idc_id != CONF.idc_id:
                req = self.db.service_get_by_idc(zone.idc_id)
                return agent.gateway_rebuild_proxy(req, body)

        user_id = self._from_body(body, 'user_id')

        user_project = self.db.user_project_get_by_id(user_id, zone_id)
        #gateways = agent.gateway_list(
        #        self.request_get(user_project.project_id))
        
        self.client.set_management_url(utils.replace_url(
                zone['auth_url'], port=CONF.agent_port, path=''))
        resp, body = self.client.get('/gateways')

        for gateway in body['gateways']:
            #self.db.gateway_create(zone_id, self._format_gateway(gateway))
            gateway['idc_id'] = CONF.idc_id
            self.db.gateway_create(zone_id, gateway)

        return webob.Response(status=202)

    # Deprecated
    @local_req
    def get_last_network_type(self, req, id):
        net_type = self.network_types.get(id, 1)
        return {'netype': {'net_type': net_type}}

    def consume(self, start, end):
        start_time = start.created_at
        delete_time = None
        if end is None:
            if start.action == 'delete':
                end_time = start.created_at
                delete_time = end_time
            else:
                end_time = timeutils.utcnow()
        else:
            end_time = end.created_at
            if end.action == 'delete':
                delete_time = end_time
        return (start_time, end_time, delete_time)

    def _format_resource(self, source):
        src = dict(source[0], usage=0, deleted_at=timeutils.utcnow())
        if src['action'] == 'create':
            if len(source) % 2 != 0:
                source.append(None)
            for i in xrange(0, len(source), 2):
                start_time, end_time, delete_time = self.consume(
                    source[i], source[i+1])
                src['usage'] += timeutils.delta_seconds(start_time, end_time)
                if delete_time is not None:
                    src['deleted_at'] = delete_time
            return src

    @local_req
    def resource_list(self, req, id):
        resources = []
        sources = collections.defaultdict(dict)
        for res in self.db.resource_get(user_id=id):
            if not sources[res.source_id].has_key(res.source_name):
                sources[res.source_id][res.source_name] = []
            sources[res.source_id][res.source_name].append(res)
        for sid, src in sources.items():
            if src.has_key('instance'):
                r = self._format_resource(src['instance'])
                if r: resources.append(r)
            if src.has_key('disk'):
                r = self._format_resource(src['disk'])
                if r: resources.append(r)
        return {'resources': resources}

    @local_req
    def resource_get(self, req, id):
        source_id = req.GET.get('source_id', None)
        source_name = req.GET.get('source_name', None)
        resources = self.db.resource_get(
            source_id=source_id, source_name=source_name, user_id=id)
        return {'resources': resources}

    @local_req
    def user_get_by_time(self, req, id):
        start_time = req.GET.get('start_time', None)
        end_time = req.GET.get('end_time', None)
        user = self.db.user_info_get(id, 'admin')
        if not user:
            msg = _("Invalid request")
            raise exc.HTTPNotFound(explanation=msg)
        return {'users': self.db.user_get_by_time(start_time, end_time)}

    def gateway_wrap(self, server):
        if server is not None:
            gateway = self.db.gateway_get_by_name(server['host'])
            if gateway is not None:
                server['uuid'] = server['id']
                server['idc_id'] = gateway['idc_id']
                server['ext_ip'] = gateway['ext_ip']
                server['gateway_ip'] = gateway['int_ip']
                server['gateway_mac'] = gateway['mac_address']
            else:
                server = None
        return server

    def server_get_by_key(self, req, project, body):
        """Get server by source mac and destination ip."""
        address = self._from_body(body, 'nw_dst')
        instance_id = self._from_body(body, 'src_id')
        has_more, _server = self.db.server_get_by_key(instance_id, address)
        server = self.gateway_wrap(_server)

        return {'server': {'has_more': has_more, 'server': server}}

    def server_get_by_id(self, req, sid, did):
        """Get server by uuid."""
        server = {}
        msg = 'Instance (%s) could not be found.'
        _server = self.db.server_get(sid)
        if not _server:
            raise exception.InstanceNotFound(msg % sid)
        server['src'] = self.gateway_wrap(_server)
        _server = self.db.server_get(did)
        if not _server:
            raise exception.InstanceNotFound(msg % did)
        server['dst'] = self.gateway_wrap(_server)

        return {'servers': server}

def create_resource():
    return wsgi.Resource(Controller())
