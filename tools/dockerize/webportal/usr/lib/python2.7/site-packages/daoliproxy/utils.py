import os
import sys
import uuid
import inspect
import pyclbr
import smtplib
from email.utils import formatdate
from email.mime.text import MIMEText

from oslo.config import cfg
import six.moves.urllib.parse as urlparse

from daoliproxy import exception
from daoliproxy.i18n import _
from daoliproxy.openstack.common import processutils
from daoliproxy.openstack.common import lockutils
from daoliproxy.openstack.common import importutils
from daoliproxy.openstack.common import log as logging

from keystoneclient.v2_0 import client as client_v2
from keystoneclient.v3 import client as client_v3

monkey_patch_opts = [
    cfg.BoolOpt('monkey_patch',
                default=False,
                help='Whether to log monkey patching'),
    cfg.ListOpt('monkey_patch_modules',
                default=[],
                help='List of modules/decorators to monkey patch'),
]

email_opts = [
    cfg.StrOpt('email_server', help='The email server'),
    cfg.StrOpt('email_name', help='The email username'),
    cfg.StrOpt('email_password', help='The email password'),
]

CONF = cfg.CONF
CONF.register_opts(monkey_patch_opts)
CONF.register_opts(email_opts)
CONF.register_opt(cfg.IntOpt('identity_version', default=2.0))

PKI_ANS1_PREFIX = 'MII'
synchronized = lockutils.synchronized_with_prefix('proxy-')

user_filters = ['admin', 'root', 'demo', 'service', 'services', 'horizon',
                'dashboard', 'nova', 'keystone', 'cinder', 'glance',
                'swift', 'ceilometer', 'heat']
def gen_uuid():
    return str(uuid.uuid1())

def monkey_patch():
    """If the CONF.monkey_patch set as True,
    this function patches a decorator
    for all functions in specified modules.
    You can set decorators for each modules
    using CONF.monkey_patch_modules.
    The format is "Module path:Decorator function".
    Example:
    'nova.api.ec2.cloud:nova.notifications.notify_decorator'

    Parameters of the decorator is as follows.
    (See nova.notifications.notify_decorator)

    name - name of the function
    function - object of the function
    """
    # If CONF.monkey_patch is not True, this function do nothing.
    if not CONF.monkey_patch:
        return
    # Get list of modules and decorators
    for module_and_decorator in CONF.monkey_patch_modules:
        module, decorator_name = module_and_decorator.split(':')
        # import decorator function
        decorator = importutils.import_class(decorator_name)
        __import__(module)
        # Retrieve module information using pyclbr
        module_data = pyclbr.readmodule_ex(module)
        for key in module_data.keys():
            # set the decorator for the class methods
            if isinstance(module_data[key], pyclbr.Class):
                clz = importutils.import_class("%s.%s" % (module, key))
                for method, func in inspect.getmembers(clz, inspect.ismethod):
                    setattr(
                        clz, method,
                        decorator("%s.%s.%s" % (module, key, method), func))
            # set the decorator for the function
            if isinstance(module_data[key], pyclbr.Function):
                func = importutils.import_class("%s.%s" % (module, key))
                setattr(sys.modules[module], key,
                        decorator("%s.%s" % (module, key), func))

def execute(*cmd, **kwargs):
    """Convenience wrapper around oslo's execute() method."""
    if 'run_as_root' in kwargs and 'root_helper' not in kwargs:
        kwargs['root_helper'] = _get_root_helper()
    return processutils.execute(*cmd, **kwargs)

def daoliproxydir():
    import daoliproxy
    return os.path.abspath(daoliproxy.__file__).split('daoliproxy/__init__.py')[0]

def read_cached_file(filename, cache_info, reload_func=None):
    """Read from a file if it has been modified.

    :param cache_info: dictionary to hold opaque cache.
    :param reload_func: optional function to be called with data when
                        file is reloaded due to a modification.

    :returns: data from file

    """
    mtime = os.path.getmtime(filename)
    if not cache_info or mtime != cache_info.get('mtime'):
        LOG.debug(_("Reloading cached file %s") % filename)
        with open(filename) as fap:
            cache_info['data'] = fap.read()
        cache_info['mtime'] = mtime
        if reload_func:
            reload_func(cache_info['data'])
    return cache_info['data']

def utf8(value):
    """Try to turn a string into utf-8 if possible.

    Code is directly from the utf8 function in
    http://github.com/facebook/tornado/blob/master/tornado/escape.py

    """
    if isinstance(value, unicode):
        return value.encode('utf-8')
    assert isinstance(value, str)
    return value

def is_ans1_token(token):
    return token[:3] == PKI_ANS1_PREFIX

def get_keystone_client():
    if CONF.identity_version < 3:
        return client_v2
    else:
        return client_v3

def authentication(username, password, auth_url, timeout=None):
    client = get_keystone_client().Client(username=username, password=password,
            project_name=username, auth_url=auth_url, debug=CONF.debug, timeout=timeout)
    return client.auth_ref

def get_service_from_catalog(catalog, service_type):
    if catalog:
        for service in catalog:
            if service['type'] == service_type:
                return service
    return None

def get_version_from_service(service):
    if service:
        endpoint = service['endpoints'][0]
        if 'interface' in endpoint:
            return 3
        else:
            return 2.0
    return 2.0

# Mapping of V2 Catalog Endpoint_type to V3 Catalog Interfaces
ENDPOINT_TYPE_TO_INTERFACE = {
    'publicURL': 'public',
    'internalURL': 'internal',
    'adminURL': 'admin',
}

def get_url_for_service(service, region, endpoint_type):
    identity_version = get_version_from_service(service)
    for endpoint in service['endpoints']:
        # ignore region for identity
        if service['type'] == 'identity' or region == endpoint['region']:
            try:
                if identity_version < 3:
                    return endpoint[endpoint_type]
                else:
                    interface = \
                        ENDPOINT_TYPE_TO_INTERFACE.get(endpoint_type, '')
                    if endpoint['interface'] == interface:
                        return endpoint['url']
            except (IndexError, KeyError):
                return None
    return None


def url_for(token, service_type, endpoint_type=None, region=None):
    endpoint_type = endpoint_type or 'publicURL'

    catalog = token.serviceCatalog
    service = get_service_from_catalog(catalog, service_type)
    if service:
        if not region:
            region = token.default_services_region
        url = get_url_for_service(service, region, endpoint_type)
        if url:
            return url

    raise exception.ServiceUnavailable()

def send_mail(receivers, timeout=20):
    sender = '%s@%s' % (CONF.email_name, CONF.email_server)
    smtp = smtplib.SMTP(timeout=timeout)
    smtp.connect('smtp.%s' % CONF.email_server)
    smtp.login(CONF.email_name, CONF.email_password)
    for rec in receivers:
        message = MIMEText(rec['body'], 'html', 'utf-8')
        message.add_header('Subject', rec['subject'])
        message.add_header('From', sender)
        message.add_header('To', rec['email'])
        message.add_header('Date', formatdate(localtime=True))
        smtp.sendmail(sender, rec['email'], message.as_string())
    smtp.quit()

def replace_url(url, host=None, port=None, path=None):
    o = urlparse.urlparse(url)
    _host = o.hostname
    _port = o.port
    _path = o.path

    if host is not None:
        _host = host

    if port is not None:
        _port = port

    netloc = _host

    if _port is not None:
        netloc = ':'.join([netloc, str(_port)])

    if path is not None:
        _path = path

    return '%s://%s%s' % (o.scheme, netloc, _path)

class LazyPluggable(object):
    """A pluggable backend loaded lazily based on some value."""

    def __init__(self, pivot, config_group=None, **backends):
        self.__backends = backends
        self.__pivot = pivot
        self.__backend = None
        self.__config_group = config_group

    def __get_backend(self):
        if not self.__backend:
            if self.__config_group is None:
                backend_name = CONF[self.__pivot]
            else:
                backend_name = CONF[self.__config_group][self.__pivot]
            if backend_name not in self.__backends:
                msg = _('Invalid backend: %s') % backend_name
                raise exception.NovaException(msg)

            backend = self.__backends[backend_name]
            if isinstance(backend, tuple):
                name = backend[0]
                fromlist = backend[1]
            else:
                name = backend
                fromlist = backend

            self.__backend = __import__(name, None, None, fromlist)
        return self.__backend

    def __getattr__(self, key):
        backend = self.__get_backend()
        return getattr(backend, key)
