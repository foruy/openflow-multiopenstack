"""Implementation of SQLAlchemy backend."""
import sys
import netaddr
import threading

from oslo.config import cfg
from oslo.db.sqlalchemy import session as db_session
from sqlalchemy import and_, or_
from sqlalchemy.sql import func

from daoliproxy.i18n import _
from daoliproxy import exception
from daoliproxy.openstack.common import uuidutils
from daoliproxy.openstack.common import timeutils
from daoliproxy.openstack.common import log as logging
from daoliproxy.openstack.common.gettextutils import _
from daoliproxy.db.sqlalchemy import models

CONF = cfg.CONF

LOG = logging.getLogger(__name__)

GATEWAY_MIN = 50000
GATEWAY_MAX = 65533

_ENGINE_FACADE = None
_LOCK = threading.Lock()

def _create_facade_lazily():
    global _LOCK, _ENGINE_FACADE
    if _ENGINE_FACADE is None:
        with _LOCK:
            if _ENGINE_FACADE is None:
                _ENGINE_FACADE = db_session.EngineFacade.from_config(CONF)
    return _ENGINE_FACADE

def get_engine(use_slave=False):
    facade = _create_facade_lazily()
    return facade.get_engine(use_slave=use_slave)

def get_session(use_slave=False, **kwargs):
    facade = _create_facade_lazily()
    return facade.get_session(use_slave=use_slave, **kwargs)

def get_backend():
    """The backend is this module itself."""
    return sys.modules[__name__]

def model_query(model, *args, **kwargs):
    session = kwargs.get('session') or get_session()
    query = session.query(model, *args)
    return query

def authenticate(username, password, **kwargs):
    session = get_session()
    with session.begin():
        user = model_query(models.User, session=session).filter_by(
            username=username, password=password).first()
        if user:
            user['updated_at'] = timeutils.utcnow()
            user_login = models.UserLogin()
            user_login.user_id = user.uuid
            user_login.updated_at = timeutils.utcnow()
            user_login.update(kwargs)
            user_login.save(session=session)
    return user

def user_get_all():
    return model_query(models.User).all()

def user_info_get(user_id, username):
    return model_query(models.User).filter_by(
        uuid=user_id, username=username).first()

def zone_get(id):
    return model_query(models.Zone).filter_by(id=id).first()

def zone_get_all():
    return model_query(models.Zone).all()

def zone_get_by_image(image_id, zones):
    session = get_session()

    image = model_query(models.Image.name, session=session).filter_by(
            id=image_id).first()
    if image is not None:
        zone_ref = model_query(models.Zone, models.Image, session=session).filter(
                models.Zone.id==models.Image.zone).filter(
                models.Zone.id.in_(zones)).filter(
                models.Image.name==image.name).filter_by(
                disabled=False).all()

        status = model_query(models.Instance.availability_zone, func.count(
                models.Instance.id), session=session).filter(
                models.Instance.availability_zone.in_(
                [z.Zone.id for z in zone_ref])).group_by(
                models.Instance.availability_zone).all()

        #zones= model_query(models.Zone.id, func.count(
        #        models.Instance.id), session=session).filter(
        #        models.Instance.availability_zone==models.Zone.id).filter(
        #        models.Zone.id==models.Image.zone).filter(
        #        models.Image.name==image.name).filter(
        #        models.Zone.id.in_(zones)).filter(models.Zone.disabled==False).group_by(
        #        models.Instance.availability_zone).all()
        #return dict((z[0], z[1]) for z in zones)
        status_dict = dict((s[0],s[1]) for s in status)

    return dict((z.Zone.id, [status_dict.get(z.Zone.id, 0),
                 z.Image.id]) for z in zone_ref)

def project_absolute_limits(project_id):
    session = get_session()
    user_project = model_query(models.UserProject,
                               session=session).filter_by(
        project_id=project_id).first()
    instance_used = model_query(func.count(models.Instance.id),
                                session=session).filter_by(
        project_id=project_id).with_lockmode('update').first()

    return {"maxTotalInstances": user_project.total_instances,
            "totalInstancesUsed": instance_used[0]}

def user_absolute_limits(user_id):
    query = model_query(func.count(models.Instance.id)).filter_by(
            user_id=user_id).with_lockmode('update')
    return query.first()

def user_project_get_by_user(user_id):
    return model_query(models.UserProject).filter_by(
            user_id=user_id).all()

def user_project_get_by_id(user_id, zone_id):
    return model_query(models.UserProject).filter_by(
            user_id=user_id, zone_id=zone_id).first()

def flavor_get_all(zone=None):
    query = model_query(models.Flavor)
    if zone is not None:
        query = query.filter_by(zone=zone)

    return query.all()

def flavor_get(id):
    return model_query(models.Flavor).filter_by(id=id).first()

def image_get_all(zone=None):
    query = model_query(models.Image)
    if zone is not None:
        query = query.filter_by(zone=zone)

    return query.all()

def image_get(id):
    return model_query(models.Image).filter_by(id=id).first()

def server_get_all(user_id=None):
    query = model_query(models.Instance)
    if user_id is not None:
        query = query.filter_by(user_id=user_id)

    query = query.order_by(models.Instance.created_at.desc())

    return query.all()

def server_get(id, session=None):
    session = session or get_session()
    return model_query(models.Instance, session=session).filter_by(id=id).first()

def server_get_by_zone(zone_id):
    return model_query(models.Instance).filter_by(availability_zone=zone_id).all()

def server_create(values):
    session = get_session()
    instance_ref = models.Instance()
    instance_ref.update(values)
    instance_ref.save(session=session)
    return instance_ref

def server_update(instance_id, values):
    session = get_session()
    server_ref = model_query(models.Instance, session=session).filter_by(
        id=instance_id).first()
    server_ref.update(values)
    server_ref.save(session=session)
    return server_ref

def server_delete(instance_id):
    session = get_session()
    with session.begin():
        model_query(models.Instance, session=session).filter_by(
            id=instance_id).delete()
        model_query(models.SingleSecurityGroup, session=session).filter(
            or_(models.SingleSecurityGroup.top==id,
                models.SingleSecurityGroup.bottom==id)
            ).delete()
        model_query(models.Firewall, session=session).filter_by(
            instance_id=instance_id).delete()

def security_group_get_by_user(user_id):
    return model_query(models.SingleSecurityGroup).filter_by(
            user_id=user_id).all()

def security_group_create(user_id, top, bot):
    session = get_session()
    group_ref = models.SingleSecurityGroup()
    group_ref.top = top
    group_ref.bottom = bot
    group_ref.user_id = user_id
    group_ref.save(session=session)
    return group_ref

def security_group_delete(user_id, top, bot):
    session = get_session()
    with session.begin():
        model_query(models.SingleSecurityGroup, session=session).filter_by(
            user_id=user_id).filter(or_(
                and_(models.SingleSecurityGroup.top==top,
                     models.SingleSecurityGroup.bottom==bot),
                and_(models.SingleSecurityGroup.top==bot,
                     models.SingleSecurityGroup.bottom==top))).delete()

def gateway_get_all(zone=None):
    query = model_query(models.Gateway)
    if zone is not None:
        query = query.filter_by(zone=zone)

    return query.all()

def gateway_get_by_idc(idc_id):
    query = model_query(models.Gateway).filter_by(idc_id=idc_id)

    query = query.filter(or_(
                models.Gateway.vext_ip!=models.Gateway.ext_ip,
                models.Gateway.int_dev!=models.Gateway.ext_dev))

    return query.all()

def gateway_get_by_name(hostname):
    return model_query(models.Gateway).filter_by(hostname=hostname).first()

def gateway_get(id=None):
    query = model_query(models.Gateway)
    if id is not None:
        query = query.filter_by(id=id)

    return query.first()

def gateway_count(hostname):
    session = get_session()
    with session.begin():
        gateway = model_query(models.Gateway, session=session).filter_by(
            hostname=hostname).with_lockmode('update').first()

        if gateway.count < GATEWAY_MIN:
            gateway.count = GATEWAY_MIN
        elif gateway.count >= GATEWAY_MAX:
            gateway.count = GATEWAY_MIN
        else:
            gateway.count = gateway.count + 1

        return gateway

def firewall_delete(firewall_id):
    model_query(models.Firewall).filter_by(id=firewall_id).delete()

def firewall_create(firewall):
    session = get_session()
    firewall_ref = models.Firewall()
    firewall_ref.update(firewall)
    firewall_ref.save(session=session)
    return firewall_ref

def firewall_get(id=None, hostname=None, gateway_port=None):
    query = model_query(models.Firewall)
    if id is not None:
        query = query.filter_by(id=id)
    if hostname is not None:
        query = query.filter_by(hostname=hostname)
    if gateway_port is not None:
        query = query.filter_by(gateway_port=gateway_port)

    return query.first()

def firewall_get_by_instance(instance_id):
    return model_query(models.Firewall).filter_by(instance_id=instance_id).all()

def server_get_by_key(instance_id, address):
    server = None
    has_more = False
    session = get_session()
    with session.begin():
        server_tmp = server_get(instance_id, session=session)
        server_ref = model_query(models.Instance, session=session).filter_by(
                user_id=server_tmp.user_id,
                address=address).first()

        if server_ref:
            has_more = True
            query = model_query(models.SingleSecurityGroup).filter(or_(
                and_(models.SingleSecurityGroup.top==server_tmp.id,
                     models.SingleSecurityGroup.bottom==server_ref.id),
                and_(models.SingleSecurityGroup.top==server_ref.id,
                     models.SingleSecurityGroup.bottom==server_tmp.id)
            ))

            if query.first():
                server = server_ref

    return (has_more, server)

def network_get_by_project(user_id, address):
    session = get_session()
    project_ref = model_query(models.UserProject.project_id).filter_by(
            user_id=user_id).all()

    projects = [p[0] for p in project_ref]
    server = model_query(models.Instance).filter(
            models.Instance.project_id.in_(projects)).filter_by(
            address=address).with_lockmode('update').first()

    return server

def generate_ip(user_id, net_type):
    """Generate an IP address."""
    session = get_session()
    subnet = model_query(models.Subnet, session=session).filter_by(
        user_id=user_id, net_type=net_type).first()

    if not subnet:
        create_subnet(user_id, net_type)

    query = model_query(models.IPAvailabilityRange,
                        session=session).join(
            models.IPAllocationPool).join(
            models.Subnet).with_lockmode('update')

    range = query.filter_by(user_id=user_id, net_type=net_type).first()

    if not range:
        LOG.debug(_("All IPs allocated"))
        return

    ip_address = range['first_ip']
    with session.begin():
        LOG.debug(_("Allocated IP - %(ip_address)s from %(first_ip)s "
                    "to %(last_ip)s"),
                  {'ip_address': ip_address,
                   'first_ip': range['first_ip'],
                   'last_ip': range['last_ip']})
        if range['first_ip'] == range['last_ip']:
            session.delete(range)
        else:
            # increment the first free
            range['first_ip'] = str(netaddr.IPAddress(ip_address) + 1)

    return ip_address

###########

def user_project_all():
    return model_query(models.UserProject).all()

def user_project_delete(zone_id):
    model_query(models.UserProject).filter_by(zone_id=zone_id).delete()

def user_project_create(user_id, project_id, keystone_user_id,
        zone_id, total_instances=None):
    session = get_session()
    user_project_ref = models.UserProject()
    user_project_ref.user_id = user_id
    user_project_ref.project_id = project_id
    user_project_ref.keystone_user_id = keystone_user_id
    user_project_ref.zone_id = zone_id
    if total_instances is not None:
        user_project_ref.total_instances = total_instances
    user_project_ref.save(session=session)
    return user_project_ref

def security_group_get_all():
    return model_query(models.SingleSecurityGroup).all()

def user_by_project_list():
    return model_query(models.UserProject.project_id, models.User).filter(
        models.UserProject.user_id==models.User.uuid).all()

def user_get(user_id):
    return model_query(models.User).filter_by(uuid=user_id).first()

def register(**values):
    session = get_session()
    user_ref = models.User()
    user_ref.update(values)
    user_ref.save(session=session)
    return user_ref

def user_task(utype, uobj):
    session = get_session()
    user_task_ref = models.UserTask()
    user_task_ref.utype = utype
    user_task_ref.uobj = uobj
    user_task_ref.save(session=session)
    return user_task_ref

def checkdata(key, val):
    query = model_query(models.User)
    if key == 'username':
        query = query.filter_by(username=val)
    elif key == 'email':
        query = query.filter_by(email=val)
    elif key == 'phone':
        query = query.filter_by(phone=val)
    else:
        raise Exception('Invalid key')

    return query.first()

def user_login_list(user_id=None):
    query = model_query(models.UserLogin)
    if user_id is not None:
        query = query.filter_by(user_id=user_id)

    query = query.order_by(models.UserLogin.updated_at.desc())

    return query.all()

def image_create(zone, values):
    session = get_session()
    image = models.Image()
    image.zone = zone
    image.update(values)
    image.save(session=session)
    return image

def image_delete(id=None, zone=None):
    query = model_query(models.Image)
    if id is not None:
        query = query.filter_by(id=id)
    elif zone is not None:
        query = query.filter_by(zone=zone)
    query.delete()

def zone_create(values):
    session = get_session()
    zone = models.Zone()
    zone.update(values)
    zone.save(session=session)
    return zone

def zone_delete(id):
    model_query(models.Zone).filter_by(id=id).delete()

def zone_update(id, values):
    session = get_session()
    zone_ref = model_query(models.Zone, session=session).filter_by(
            id=id).first()

    if not zone_ref:
        # Zone may be empty when administrator deleted
        return
    zone_ref.update(values)
    zone_ref.save(session=session)
    return zone_ref

def zone_exists(auth_url=None):
    query = model_query(models.Zone)
    if auth_url is not None:
        query = query.filter_by(auth_url=auth_url)

    return query.first()

def flavor_create(zone, values):
    session = get_session()
    flavor = models.Flavor()
    flavor.zone = zone
    flavor.update(values)
    flavor.save(session=session)
    return flavor

def flavor_delete(id=None, zone=None):
    query = model_query(models.Flavor)
    if id is not None:
        query = query.filter_by(id=id)
    elif zone is not None:
        query = query.filter_by(zone=zone)
    query.delete()

def gateway_create(zone, values):
    session = get_session()
    gateway = models.Gateway()
    gateway.zone = zone
    gateway.update(values)
    gateway.save(session=session)
    return gateway

def gateway_delete(id=None, zone=None):
    query = model_query(models.Gateway)
    if id is not None:
        query = query.filter_by(id=id)
    elif zone is not None:
        query = query.filter_by(zone=zone)
    query.delete()

def gateway_update(hostname, **value):
    session = get_session()
    gateway = model_query(models.Gateway, session=session).filter_by(
            hostname=hostname).first()

    with session.begin():
        gateway.update(value)

    return gateway

def notify_about_resource(source_name, source_id, action,
                          project_id, user_id, extra={}):
    session = get_session()
    resource = models.Resource()
    resource.source_name = source_name
    resource.source_id = source_id
    resource.action = action
    resource.extra = extra
    resource.project_id = project_id
    resource.user_id = user_id
    resource.save(session=session)
    return resource

def resource_get(source_id=None, source_name=None, action=None,
                 project_id=None, user_id=None):
    query = model_query(models.Resource)
    if source_id:
        query = query.filter_by(source_id=source_id)
    if source_name:
        query = query.filter_by(source_name=source_name)
    if action:
        query = query.filter_by(action=action)
    if project_id:
        query = query.filter_by(project_id=project_id)
    if user_id:
        query = query.filter_by(user_id=user_id)
    return query.all()

#################################

def create_subnet(user_id, net_type, subnet=None):
    session = get_session()

    if subnet is None:
        subnet = {'cidr': network_type_get(net_type).cidr}

    net = netaddr.IPNetwork(subnet['cidr'])

    if not subnet.has_key('gateway_ip') or subnet['gateway_ip'] is None:
        subnet['gateway_ip'] = str(netaddr.IPAddress(net.last - 1))

    pool = {'start': str(netaddr.IPAddress(net.first + 2)),
            'end': str(netaddr.IPAddress(net.last - 2))}

    with session.begin():
        args = {'id': subnet.get('id') or uuidutils.generate_uuid(),
                'name': subnet.get('name', ''),
                'cidr': subnet['cidr'],
                'gateway_ip': subnet['gateway_ip'],
                'net_type': net_type,
                'user_id': user_id}
        subnet = models.Subnet(**args)
        session.add(subnet)

        ip_pool = models.IPAllocationPool(subnet=subnet,
                                          first_ip=pool['start'],
                                          last_ip=pool['end'])
        session.add(ip_pool)
        ip_range = models.IPAvailabilityRange(
                ipallocationpool=ip_pool,
                first_ip=pool['start'],
                last_ip=pool['end'])
        session.add(ip_range)

    return subnet

def security_group_get_by_user(user_id):
    return model_query(models.SingleSecurityGroup).filter_by(
        user_id=user_id).all()

def user_get_by_time(start_time=None, end_time=None):
    session = get_session()
    with session.begin():
        data = {}
        query = model_query(models.User, func.count(
            models.UserLogin.user_id), session=session).filter(
            models.User.uuid==models.UserLogin.user_id)
        if start_time:
            query = query.filter(models.UserLogin.updated_at>=start_time)
        if end_time:
            query = query.filter(models.UserLogin.updated_at<=end_time)
        for user in query.group_by(models.User.uuid).all():
            data[user.User.uuid] = {"id": user.User.uuid,
                                    "username": user.User.username,
                                    "email": user.User.email,
                                    "phone": user.User.phone,
                                    "company": user.User.company,
                                    "lognum": user[1]}
        query = model_query(models.Resource.user_id, func.count(
            models.Resource.user_id), session=session)
        if start_time:
            query = query.filter(models.Resource.created_at>=start_time)
        if end_time:
            query = query.filter(models.Resource.created_at<=end_time)
        resources = query.filter_by(
            action='create').group_by(models.Resource.user_id).all()
        for res in resources:
            data[res.user_id]["count"] = res[1]

        return data.values()

def validate_user(user, session=None):
    session = session or get_session()

    query = model_query(models.User, session=session)
    for k, v in user.items():
        if isinstance(v, unicode):
            v = '"%s"' % v
        query = query.filter('%s=%s' % (k, v))

    return query.first()

def update_user(base, **values):
    session = get_session()

    with session.begin():
        user_ref = validate_user(base, session=session)

        if not user_ref:
            raise exception.NotFound("User not found.")

        user_ref.update(values)

        return user_ref

def user_delete(user_id):
    session = get_session()

    with session.begin():
        model_query(models.UserProject, session=session).filter_by(
            user_id=user_id).delete()
        model_query(models.UserLogin, session=session).filter_by(
            user_id=user_id).delete()
        model_query(models.User, session=session).filter_by(
            uuid=user_id).delete()

def service_get_by_idc(idc_id):
    return model_query(models.Service).filter_by(
            idc_id=idc_id).first()

#def service_get(zone_id):
#    return model_query(models.Service).filter_by(zone_id=zone_id).first()

def service_create(values):
    session = get_session()

    with session.begin():
        service_ref = model_query(models.Service, session=session).filter_by(
                name=values['name']).first()

        if service_ref:
            service_ref.update(values)
        else:
            service_ref = models.Service()
            service_ref.update(values)
            service_ref.save(session=session)

    return service_ref


def network_get(net_id=None, zone_id=None):
    query = model_query(models.Network.id,
                        models.NetworkType.cidr).filter(
            models.Network.netype==models.NetworkType.id)

    if net_id is not None:
        query = query.filter(
            models.Network.netype==net_id)

    if zone_id is not None:
        query = query.filter(
            models.Network.zone_id==zone_id)

    result = query.first()

    if not result:
        raise exception.NetworkTypeNotFound(id= net_id or zone_id)

    return result

def network_get_all(zone=None):
    query = model_query(models.Network)
    if zone is not None:
        query = query.filter_by(zone_id=zone)

    return query.all()

def network_create(zone, values):
    session = get_session()
    network = models.Network()
    network.zone_id = zone
    network.update(values)
    network.save(session=session)
    return network

def network_delete(id=None, zone=None):
    query = model_query(models.Network)
    if id is not None:
        query = query.filter_by(id=id)
    elif zone is not None:
        query = query.filter_by(zone_id=zone)
    query.delete()

def network_type_get(id=None):
    query = model_query(models.NetworkType)

    if id is not None:
        network_type_ref = query.filter_by(id=id).first()

        if not network_type_ref:
            raise exception.NetworkTypeNotFound(id=id)
    else:
        network_type_ref = query.all()

    return network_type_ref

def network_type_update(cidr):
    session = get_session()

    with session.begin():
        network_type = model_query(models.NetworkType,
                session=session).filter_by(cidr=cidr).first()

        if not network_type:
            network_type = models.NetworkType()
            network_type.cidr = cidr
            network_type.save(session=session)

    return network_type

def network_type_delete(id):
    model_query(models.NetworkType).filter_by(id=id).delete()
